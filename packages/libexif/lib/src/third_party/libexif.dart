// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Dart bindings to libexif
class LibExif {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibExif(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibExif.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ffi.Char> mnote_apple_tag_get_name(
    int arg0,
  ) {
    return _mnote_apple_tag_get_name(
      arg0,
    );
  }

  late final _mnote_apple_tag_get_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'mnote_apple_tag_get_name');
  late final _mnote_apple_tag_get_name = _mnote_apple_tag_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<ffi.Char> mnote_apple_tag_get_title(
    int arg0,
  ) {
    return _mnote_apple_tag_get_title(
      arg0,
    );
  }

  late final _mnote_apple_tag_get_titlePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'mnote_apple_tag_get_title');
  late final _mnote_apple_tag_get_title = _mnote_apple_tag_get_titlePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<ffi.Char> mnote_apple_tag_get_description(
    int arg0,
  ) {
    return _mnote_apple_tag_get_description(
      arg0,
    );
  }

  late final _mnote_apple_tag_get_descriptionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'mnote_apple_tag_get_description');
  late final _mnote_apple_tag_get_description =
      _mnote_apple_tag_get_descriptionPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! Return a short, localized, textual name for the given byte order.
  /// \param[in] order byte order
  /// \return localized textual name of the byte order, or NULL if unknown
  ffi.Pointer<ffi.Char> exif_byte_order_get_name(
    int order,
  ) {
    return _exif_byte_order_get_name(
      order,
    );
  }

  late final _exif_byte_order_get_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'exif_byte_order_get_name');
  late final _exif_byte_order_get_name = _exif_byte_order_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! Return a textual name of the given IFD. The name is a short, unique,
  /// non-localized text string containing only US-ASCII alphanumeric
  /// characters.
  ///
  /// \param[in] ifd IFD
  /// \return textual name of the IFD, or NULL if unknown
  ffi.Pointer<ffi.Char> exif_ifd_get_name(
    int ifd,
  ) {
    return _exif_ifd_get_name(
      ifd,
    );
  }

  late final _exif_ifd_get_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'exif_ifd_get_name');
  late final _exif_ifd_get_name =
      _exif_ifd_get_namePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! Return a textual representation of the given EXIF data type.
  ///
  /// \param[in] format EXIF data format
  /// \return localized textual name, or NULL if unknown
  ffi.Pointer<ffi.Char> exif_format_get_name(
    int format,
  ) {
    return _exif_format_get_name(
      format,
    );
  }

  late final _exif_format_get_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'exif_format_get_name');
  late final _exif_format_get_name = _exif_format_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! Return the raw size of the given EXIF data type.
  ///
  /// \param[in] format EXIF data format
  /// \return size in bytes
  int exif_format_get_size(
    int format,
  ) {
    return _exif_format_get_size(
      format,
    );
  }

  late final _exif_format_get_sizePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedChar Function(ffi.Int32)>>(
          'exif_format_get_size');
  late final _exif_format_get_size =
      _exif_format_get_sizePtr.asFunction<int Function(int)>();

  /// ! Retrieve an #ExifShort value from memory.
  ///
  /// \param[in] b pointer to raw EXIF value in memory
  /// \param[in] order byte order of raw value
  /// \return value
  int exif_get_short(
    ffi.Pointer<ffi.UnsignedChar> b,
    int order,
  ) {
    return _exif_get_short(
      b,
      order,
    );
  }

  late final _exif_get_shortPtr = _lookup<
      ffi.NativeFunction<
          ExifShort Function(
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int32)>>('exif_get_short');
  late final _exif_get_short = _exif_get_shortPtr
      .asFunction<int Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// ! Retrieve an #ExifSShort value from memory.
  ///
  /// \param[in] b pointer to raw EXIF value in memory
  /// \param[in] order byte order of raw value
  /// \return value
  int exif_get_sshort(
    ffi.Pointer<ffi.UnsignedChar> b,
    int order,
  ) {
    return _exif_get_sshort(
      b,
      order,
    );
  }

  late final _exif_get_sshortPtr = _lookup<
      ffi.NativeFunction<
          ExifSShort Function(
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int32)>>('exif_get_sshort');
  late final _exif_get_sshort = _exif_get_sshortPtr
      .asFunction<int Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// ! Retrieve an #ExifLong value from memory.
  ///
  /// \param[in] b pointer to raw EXIF value in memory
  /// \param[in] order byte order of raw value
  /// \return value
  int exif_get_long(
    ffi.Pointer<ffi.UnsignedChar> b,
    int order,
  ) {
    return _exif_get_long(
      b,
      order,
    );
  }

  late final _exif_get_longPtr = _lookup<
      ffi.NativeFunction<
          ExifLong Function(
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int32)>>('exif_get_long');
  late final _exif_get_long = _exif_get_longPtr
      .asFunction<int Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// ! Retrieve an #ExifSLong value from memory.
  ///
  /// \param[in] b pointer to raw EXIF value in memory
  /// \param[in] order byte order of raw value
  /// \return value
  int exif_get_slong(
    ffi.Pointer<ffi.UnsignedChar> b,
    int order,
  ) {
    return _exif_get_slong(
      b,
      order,
    );
  }

  late final _exif_get_slongPtr = _lookup<
      ffi.NativeFunction<
          ExifSLong Function(
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int32)>>('exif_get_slong');
  late final _exif_get_slong = _exif_get_slongPtr
      .asFunction<int Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// ! Retrieve an #ExifRational value from memory.
  ///
  /// \param[in] b pointer to raw EXIF value in memory
  /// \param[in] order byte order of raw value
  /// \return value
  ExifRational exif_get_rational(
    ffi.Pointer<ffi.UnsignedChar> b,
    int order,
  ) {
    return _exif_get_rational(
      b,
      order,
    );
  }

  late final _exif_get_rationalPtr = _lookup<
      ffi.NativeFunction<
          ExifRational Function(
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int32)>>('exif_get_rational');
  late final _exif_get_rational = _exif_get_rationalPtr
      .asFunction<ExifRational Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// ! Retrieve an #ExifSRational value from memory.
  ///
  /// \param[in] b pointer to raw EXIF value in memory
  /// \param[in] order byte order of raw value
  /// \return value
  ExifSRational exif_get_srational(
    ffi.Pointer<ffi.UnsignedChar> b,
    int order,
  ) {
    return _exif_get_srational(
      b,
      order,
    );
  }

  late final _exif_get_srationalPtr = _lookup<
      ffi.NativeFunction<
          ExifSRational Function(
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int32)>>('exif_get_srational');
  late final _exif_get_srational = _exif_get_srationalPtr
      .asFunction<ExifSRational Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// ! Store an ExifShort value into memory in EXIF format.
  ///
  /// \param[out] b buffer in which to write raw value
  /// \param[in] order byte order to use
  /// \param[in] value data value to store
  void exif_set_short(
    ffi.Pointer<ffi.UnsignedChar> b,
    int order,
    int value,
  ) {
    return _exif_set_short(
      b,
      order,
      value,
    );
  }

  late final _exif_set_shortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedChar>, ffi.Int32,
              ExifShort)>>('exif_set_short');
  late final _exif_set_short = _exif_set_shortPtr
      .asFunction<void Function(ffi.Pointer<ffi.UnsignedChar>, int, int)>();

  /// ! Store an ExifSShort value into memory in EXIF format.
  ///
  /// \param[out] b buffer in which to write raw value
  /// \param[in] order byte order to use
  /// \param[in] value data value to store
  void exif_set_sshort(
    ffi.Pointer<ffi.UnsignedChar> b,
    int order,
    int value,
  ) {
    return _exif_set_sshort(
      b,
      order,
      value,
    );
  }

  late final _exif_set_sshortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedChar>, ffi.Int32,
              ExifSShort)>>('exif_set_sshort');
  late final _exif_set_sshort = _exif_set_sshortPtr
      .asFunction<void Function(ffi.Pointer<ffi.UnsignedChar>, int, int)>();

  /// ! Store an ExifLong value into memory in EXIF format.
  ///
  /// \param[out] b buffer in which to write raw value
  /// \param[in] order byte order to use
  /// \param[in] value data value to store
  void exif_set_long(
    ffi.Pointer<ffi.UnsignedChar> b,
    int order,
    int value,
  ) {
    return _exif_set_long(
      b,
      order,
      value,
    );
  }

  late final _exif_set_longPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedChar>, ffi.Int32,
              ExifLong)>>('exif_set_long');
  late final _exif_set_long = _exif_set_longPtr
      .asFunction<void Function(ffi.Pointer<ffi.UnsignedChar>, int, int)>();

  /// ! Store an ExifSLong value into memory in EXIF format.
  ///
  /// \param[out] b buffer in which to write raw value
  /// \param[in] order byte order to use
  /// \param[in] value data value to store
  void exif_set_slong(
    ffi.Pointer<ffi.UnsignedChar> b,
    int order,
    int value,
  ) {
    return _exif_set_slong(
      b,
      order,
      value,
    );
  }

  late final _exif_set_slongPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedChar>, ffi.Int32,
              ExifSLong)>>('exif_set_slong');
  late final _exif_set_slong = _exif_set_slongPtr
      .asFunction<void Function(ffi.Pointer<ffi.UnsignedChar>, int, int)>();

  /// ! Store an ExifRational value into memory in EXIF format.
  ///
  /// \param[out] b buffer in which to write raw value
  /// \param[in] order byte order to use
  /// \param[in] value data value to store
  void exif_set_rational(
    ffi.Pointer<ffi.UnsignedChar> b,
    int order,
    ExifRational value,
  ) {
    return _exif_set_rational(
      b,
      order,
      value,
    );
  }

  late final _exif_set_rationalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedChar>, ffi.Int32,
              ExifRational)>>('exif_set_rational');
  late final _exif_set_rational = _exif_set_rationalPtr.asFunction<
      void Function(ffi.Pointer<ffi.UnsignedChar>, int, ExifRational)>();

  /// ! Store an ExifSRational value into memory in EXIF format.
  ///
  /// \param[out] b buffer in which to write raw value
  /// \param[in] order byte order to use
  /// \param[in] value data value to store
  void exif_set_srational(
    ffi.Pointer<ffi.UnsignedChar> b,
    int order,
    ExifSRational value,
  ) {
    return _exif_set_srational(
      b,
      order,
      value,
    );
  }

  late final _exif_set_srationalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedChar>, ffi.Int32,
              ExifSRational)>>('exif_set_srational');
  late final _exif_set_srational = _exif_set_srationalPtr.asFunction<
      void Function(ffi.Pointer<ffi.UnsignedChar>, int, ExifSRational)>();

  /// ! \internal
  void exif_convert_utf16_to_utf8(
    ffi.Pointer<ffi.Char> out,
    ffi.Pointer<ffi.UnsignedChar> in1,
    int maxlen,
  ) {
    return _exif_convert_utf16_to_utf8(
      out,
      in1,
      maxlen,
    );
  }

  late final _exif_convert_utf16_to_utf8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int)>>('exif_convert_utf16_to_utf8');
  late final _exif_convert_utf16_to_utf8 =
      _exif_convert_utf16_to_utf8Ptr.asFunction<
          void Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// ! \internal
  void exif_array_set_byte_order(
    int arg0,
    ffi.Pointer<ffi.UnsignedChar> arg1,
    int arg2,
    int o_orig,
    int o_new,
  ) {
    return _exif_array_set_byte_order(
      arg0,
      arg1,
      arg2,
      o_orig,
      o_new,
    );
  }

  late final _exif_array_set_byte_orderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int32,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedInt,
              ffi.Int32,
              ffi.Int32)>>('exif_array_set_byte_order');
  late final _exif_array_set_byte_order =
      _exif_array_set_byte_orderPtr.asFunction<
          void Function(int, ffi.Pointer<ffi.UnsignedChar>, int, int, int)>();

  /// ! Create a new ExifMem
  ///
  /// \param[in] a the allocator function
  /// \param[in] r the reallocator function
  /// \param[in] f the free function
  /// \return allocated #ExifMem, or NULL on error
  ffi.Pointer<ExifMem> exif_mem_new(
    ExifMemAllocFunc a,
    ExifMemReallocFunc r,
    ExifMemFreeFunc f,
  ) {
    return _exif_mem_new(
      a,
      r,
      f,
    );
  }

  late final _exif_mem_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ExifMem> Function(ExifMemAllocFunc, ExifMemReallocFunc,
              ExifMemFreeFunc)>>('exif_mem_new');
  late final _exif_mem_new = _exif_mem_newPtr.asFunction<
      ffi.Pointer<ExifMem> Function(
          ExifMemAllocFunc, ExifMemReallocFunc, ExifMemFreeFunc)>();

  /// ! Refcount an ExifMem
  void exif_mem_ref(
    ffi.Pointer<ExifMem> arg0,
  ) {
    return _exif_mem_ref(
      arg0,
    );
  }

  late final _exif_mem_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifMem>)>>(
          'exif_mem_ref');
  late final _exif_mem_ref =
      _exif_mem_refPtr.asFunction<void Function(ffi.Pointer<ExifMem>)>();

  /// ! Unrefcount an ExifMem.
  /// If the refcount reaches 0, the ExifMem is freed
  void exif_mem_unref(
    ffi.Pointer<ExifMem> arg0,
  ) {
    return _exif_mem_unref(
      arg0,
    );
  }

  late final _exif_mem_unrefPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifMem>)>>(
          'exif_mem_unref');
  late final _exif_mem_unref =
      _exif_mem_unrefPtr.asFunction<void Function(ffi.Pointer<ExifMem>)>();

  ffi.Pointer<ffi.Void> exif_mem_alloc(
    ffi.Pointer<ExifMem> m,
    int s,
  ) {
    return _exif_mem_alloc(
      m,
      s,
    );
  }

  late final _exif_mem_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ExifMem>, ExifLong)>>('exif_mem_alloc');
  late final _exif_mem_alloc = _exif_mem_allocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ExifMem>, int)>();

  ffi.Pointer<ffi.Void> exif_mem_realloc(
    ffi.Pointer<ExifMem> m,
    ffi.Pointer<ffi.Void> p,
    int s,
  ) {
    return _exif_mem_realloc(
      m,
      p,
      s,
    );
  }

  late final _exif_mem_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ExifMem>,
              ffi.Pointer<ffi.Void>, ExifLong)>>('exif_mem_realloc');
  late final _exif_mem_realloc = _exif_mem_reallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ExifMem>, ffi.Pointer<ffi.Void>, int)>();

  void exif_mem_free(
    ffi.Pointer<ExifMem> m,
    ffi.Pointer<ffi.Void> p,
  ) {
    return _exif_mem_free(
      m,
      p,
    );
  }

  late final _exif_mem_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ExifMem>, ffi.Pointer<ffi.Void>)>>('exif_mem_free');
  late final _exif_mem_free = _exif_mem_freePtr
      .asFunction<void Function(ffi.Pointer<ExifMem>, ffi.Pointer<ffi.Void>)>();

  /// ! Create a new ExifMem with default values for your convenience
  ///
  /// \return return a new default ExifMem
  ffi.Pointer<ExifMem> exif_mem_new_default() {
    return _exif_mem_new_default();
  }

  late final _exif_mem_new_defaultPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ExifMem> Function()>>(
          'exif_mem_new_default');
  late final _exif_mem_new_default =
      _exif_mem_new_defaultPtr.asFunction<ffi.Pointer<ExifMem> Function()>();

  /// ! Create a new logging instance.
  /// \see exif_log_free
  ///
  /// \return new instance of #ExifLog
  ffi.Pointer<ExifLog> exif_log_new() {
    return _exif_log_new();
  }

  late final _exif_log_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ExifLog> Function()>>(
          'exif_log_new');
  late final _exif_log_new =
      _exif_log_newPtr.asFunction<ffi.Pointer<ExifLog> Function()>();

  ffi.Pointer<ExifLog> exif_log_new_mem(
    ffi.Pointer<ExifMem> arg0,
  ) {
    return _exif_log_new_mem(
      arg0,
    );
  }

  late final _exif_log_new_memPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<ExifLog> Function(ffi.Pointer<ExifMem>)>>(
      'exif_log_new_mem');
  late final _exif_log_new_mem = _exif_log_new_memPtr
      .asFunction<ffi.Pointer<ExifLog> Function(ffi.Pointer<ExifMem>)>();

  void exif_log_ref(
    ffi.Pointer<ExifLog> log,
  ) {
    return _exif_log_ref(
      log,
    );
  }

  late final _exif_log_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifLog>)>>(
          'exif_log_ref');
  late final _exif_log_ref =
      _exif_log_refPtr.asFunction<void Function(ffi.Pointer<ExifLog>)>();

  void exif_log_unref(
    ffi.Pointer<ExifLog> log,
  ) {
    return _exif_log_unref(
      log,
    );
  }

  late final _exif_log_unrefPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifLog>)>>(
          'exif_log_unref');
  late final _exif_log_unref =
      _exif_log_unrefPtr.asFunction<void Function(ffi.Pointer<ExifLog>)>();

  /// ! Delete instance of #ExifLog.
  /// \see exif_log_new
  ///
  /// \param[in] log #ExifLog
  /// \return new instance of #ExifLog
  void exif_log_free(
    ffi.Pointer<ExifLog> log,
  ) {
    return _exif_log_free(
      log,
    );
  }

  late final _exif_log_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifLog>)>>(
          'exif_log_free');
  late final _exif_log_free =
      _exif_log_freePtr.asFunction<void Function(ffi.Pointer<ExifLog>)>();

  /// ! Return a textual description of the given class of error log.
  ///
  /// \param[in] code logging message class
  /// \return textual description of the log class, or NULL if unknown
  ffi.Pointer<ffi.Char> exif_log_code_get_title(
    int code,
  ) {
    return _exif_log_code_get_title(
      code,
    );
  }

  late final _exif_log_code_get_titlePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'exif_log_code_get_title');
  late final _exif_log_code_get_title = _exif_log_code_get_titlePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! Return a verbose description of the given class of error log.
  ///
  /// \param[in] code logging message class
  /// \return verbose description of the log class, or NULL if unknown
  ffi.Pointer<ffi.Char> exif_log_code_get_message(
    int code,
  ) {
    return _exif_log_code_get_message(
      code,
    );
  }

  late final _exif_log_code_get_messagePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'exif_log_code_get_message');
  late final _exif_log_code_get_message = _exif_log_code_get_messagePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! Register log callback function.
  /// Calls to the log callback function are purely for diagnostic purposes.
  ///
  /// \param[in] log logging state variable
  /// \param[in] func callback function to set
  /// \param[in] data data to pass into callback function
  void exif_log_set_func(
    ffi.Pointer<ExifLog> log,
    ExifLogFunc func,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _exif_log_set_func(
      log,
      func,
      data,
    );
  }

  late final _exif_log_set_funcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ExifLog>, ExifLogFunc,
              ffi.Pointer<ffi.Void>)>>('exif_log_set_func');
  late final _exif_log_set_func = _exif_log_set_funcPtr.asFunction<
      void Function(
          ffi.Pointer<ExifLog>, ExifLogFunc, ffi.Pointer<ffi.Void>)>();

  void exif_log(
    ffi.Pointer<ExifLog> log,
    int arg1,
    ffi.Pointer<ffi.Char> domain,
    ffi.Pointer<ffi.Char> format,
  ) {
    return _exif_log(
      log,
      arg1,
      domain,
      format,
    );
  }

  late final _exif_logPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ExifLog>, ffi.Int32,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('exif_log');
  late final _exif_log = _exif_logPtr.asFunction<
      void Function(ffi.Pointer<ExifLog>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  void exif_logv(
    ffi.Pointer<ExifLog> log,
    int arg1,
    ffi.Pointer<ffi.Char> domain,
    ffi.Pointer<ffi.Char> format,
    va_list args,
  ) {
    return _exif_logv(
      log,
      arg1,
      domain,
      format,
      args,
    );
  }

  late final _exif_logvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ExifLog>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              va_list)>>('exif_logv');
  late final _exif_logv = _exif_logvPtr.asFunction<
      void Function(ffi.Pointer<ExifLog>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, va_list)>();

  /// ! Return the tag ID given its unique textual name.
  ///
  /// \param[in] name tag name
  /// \return tag ID, or 0 if tag not found
  /// \note The tag not found value cannot be distinguished from a legitimate
  /// tag number 0.
  int exif_tag_from_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _exif_tag_from_name(
      name,
    );
  }

  late final _exif_tag_from_namePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'exif_tag_from_name');
  late final _exif_tag_from_name =
      _exif_tag_from_namePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// ! Return a textual name of the given tag when found in the given IFD. The
  /// name is a short, unique, non-localized text string containing only
  /// US-ASCII alphanumeric characters.
  ///
  /// \param[in] tag EXIF tag
  /// \param[in] ifd IFD
  /// \return textual name of the tag, or NULL if the tag is unknown
  ffi.Pointer<ffi.Char> exif_tag_get_name_in_ifd(
    int tag,
    int ifd,
  ) {
    return _exif_tag_get_name_in_ifd(
      tag,
      ifd,
    );
  }

  late final _exif_tag_get_name_in_ifdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int32, ffi.Int32)>>('exif_tag_get_name_in_ifd');
  late final _exif_tag_get_name_in_ifd = _exif_tag_get_name_in_ifdPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int, int)>();

  /// ! Return a textual title of the given tag when found in the given IFD.
  /// The title is a short, localized description of the tag.
  ///
  /// \param[in] tag EXIF tag
  /// \param[in] ifd IFD
  /// \return textual title of the tag, or NULL if the tag is unknown
  ffi.Pointer<ffi.Char> exif_tag_get_title_in_ifd(
    int tag,
    int ifd,
  ) {
    return _exif_tag_get_title_in_ifd(
      tag,
      ifd,
    );
  }

  late final _exif_tag_get_title_in_ifdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int32, ffi.Int32)>>('exif_tag_get_title_in_ifd');
  late final _exif_tag_get_title_in_ifd = _exif_tag_get_title_in_ifdPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int, int)>();

  /// ! Return a verbose textual description of the given tag when found in the
  /// given IFD. The description is a verbose, localized description of the tag.
  ///
  /// \param[in] tag EXIF tag
  /// \param[in] ifd IFD
  /// \return textual description of the tag, or NULL if the tag is unknown
  ffi.Pointer<ffi.Char> exif_tag_get_description_in_ifd(
    int tag,
    int ifd,
  ) {
    return _exif_tag_get_description_in_ifd(
      tag,
      ifd,
    );
  }

  late final _exif_tag_get_description_in_ifdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int32, ffi.Int32)>>('exif_tag_get_description_in_ifd');
  late final _exif_tag_get_description_in_ifd =
      _exif_tag_get_description_in_ifdPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(int, int)>();

  /// ! Return whether the given tag is mandatory or not in the given IFD and
  /// data type according to the EXIF specification. If the IFD given is
  /// EXIF_IFD_COUNT, the result is EXIF_SUPPORT_LEVEL_UNKNOWN. If the data
  /// type is EXIF_DATA_TYPE_UNKNOWN, the result is
  /// EXIF_SUPPORT_LEVEL_UNKNOWN unless the support level is the same for
  /// all data types.
  ///
  /// \param[in] tag EXIF tag
  /// \param[in] ifd IFD or EXIF_IFD_COUNT
  /// \param[in] t data type or EXIF_DATA_TYPE_UNKNOWN
  /// \return the level of support for this tag
  int exif_tag_get_support_level_in_ifd(
    int tag,
    int ifd,
    int t,
  ) {
    return _exif_tag_get_support_level_in_ifd(
      tag,
      ifd,
      t,
    );
  }

  late final _exif_tag_get_support_level_in_ifdPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Int32, ffi.Int32, ffi.Int32)>>(
      'exif_tag_get_support_level_in_ifd');
  late final _exif_tag_get_support_level_in_ifd =
      _exif_tag_get_support_level_in_ifdPtr
          .asFunction<int Function(int, int, int)>();

  /// ! \deprecated Use #exif_tag_get_name_in_ifd instead
  ffi.Pointer<ffi.Char> exif_tag_get_name(
    int tag,
  ) {
    return _exif_tag_get_name(
      tag,
    );
  }

  late final _exif_tag_get_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'exif_tag_get_name');
  late final _exif_tag_get_name =
      _exif_tag_get_namePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! \deprecated Use #exif_tag_get_title_in_ifd instead
  ffi.Pointer<ffi.Char> exif_tag_get_title(
    int tag,
  ) {
    return _exif_tag_get_title(
      tag,
    );
  }

  late final _exif_tag_get_titlePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'exif_tag_get_title');
  late final _exif_tag_get_title =
      _exif_tag_get_titlePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! \deprecated Use #exif_tag_get_description_in_ifd instead
  ffi.Pointer<ffi.Char> exif_tag_get_description(
    int tag,
  ) {
    return _exif_tag_get_description(
      tag,
    );
  }

  late final _exif_tag_get_descriptionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'exif_tag_get_description');
  late final _exif_tag_get_description = _exif_tag_get_descriptionPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! \internal
  int exif_tag_table_get_tag(
    int n,
  ) {
    return _exif_tag_table_get_tag(
      n,
    );
  }

  late final _exif_tag_table_get_tagPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.UnsignedInt)>>(
          'exif_tag_table_get_tag');
  late final _exif_tag_table_get_tag =
      _exif_tag_table_get_tagPtr.asFunction<int Function(int)>();

  /// ! \internal
  ffi.Pointer<ffi.Char> exif_tag_table_get_name(
    int n,
  ) {
    return _exif_tag_table_get_name(
      n,
    );
  }

  late final _exif_tag_table_get_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'exif_tag_table_get_name');
  late final _exif_tag_table_get_name = _exif_tag_table_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! \internal
  int exif_tag_table_count() {
    return _exif_tag_table_count();
  }

  late final _exif_tag_table_countPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'exif_tag_table_count');
  late final _exif_tag_table_count =
      _exif_tag_table_countPtr.asFunction<int Function()>();

  /// ! Reserve memory for and initialize a new #ExifEntry.
  /// No memory is allocated for the \c data element of the returned #ExifEntry.
  ///
  /// \return new allocated #ExifEntry, or NULL on error
  ///
  /// \see exif_entry_new_mem, exif_entry_unref
  ffi.Pointer<ExifEntry> exif_entry_new() {
    return _exif_entry_new();
  }

  late final _exif_entry_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ExifEntry> Function()>>(
          'exif_entry_new');
  late final _exif_entry_new =
      _exif_entry_newPtr.asFunction<ffi.Pointer<ExifEntry> Function()>();

  /// ! Reserve memory for and initialize new #ExifEntry using the specified
  /// memory allocator.
  /// No memory is allocated for the \c data element of the returned #ExifEntry.
  ///
  /// \return new allocated #ExifEntry, or NULL on error
  ///
  /// \see exif_entry_new, exif_entry_unref
  ffi.Pointer<ExifEntry> exif_entry_new_mem(
    ffi.Pointer<ExifMem> arg0,
  ) {
    return _exif_entry_new_mem(
      arg0,
    );
  }

  late final _exif_entry_new_memPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ExifEntry> Function(
              ffi.Pointer<ExifMem>)>>('exif_entry_new_mem');
  late final _exif_entry_new_mem = _exif_entry_new_memPtr
      .asFunction<ffi.Pointer<ExifEntry> Function(ffi.Pointer<ExifMem>)>();

  /// ! Increase reference counter for #ExifEntry.
  ///
  /// \param[in] entry #ExifEntry
  ///
  /// \see exif_entry_unref
  void exif_entry_ref(
    ffi.Pointer<ExifEntry> entry,
  ) {
    return _exif_entry_ref(
      entry,
    );
  }

  late final _exif_entry_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifEntry>)>>(
          'exif_entry_ref');
  late final _exif_entry_ref =
      _exif_entry_refPtr.asFunction<void Function(ffi.Pointer<ExifEntry>)>();

  /// ! Decrease reference counter for #ExifEntry.
  /// When the reference count drops to zero, free the entry.
  ///
  /// \param[in] entry #ExifEntry
  void exif_entry_unref(
    ffi.Pointer<ExifEntry> entry,
  ) {
    return _exif_entry_unref(
      entry,
    );
  }

  late final _exif_entry_unrefPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifEntry>)>>(
          'exif_entry_unref');
  late final _exif_entry_unref =
      _exif_entry_unrefPtr.asFunction<void Function(ffi.Pointer<ExifEntry>)>();

  /// ! Actually free the #ExifEntry.
  ///
  /// \deprecated Should not be called directly. Use #exif_entry_ref and
  /// #exif_entry_unref instead.
  ///
  /// \param[in] entry EXIF entry
  void exif_entry_free(
    ffi.Pointer<ExifEntry> entry,
  ) {
    return _exif_entry_free(
      entry,
    );
  }

  late final _exif_entry_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifEntry>)>>(
          'exif_entry_free');
  late final _exif_entry_free =
      _exif_entry_freePtr.asFunction<void Function(ffi.Pointer<ExifEntry>)>();

  /// ! Initialize an empty #ExifEntry with default data in the correct format
  /// for the given tag. If the entry is already initialized, this function
  /// does nothing.
  /// This call allocates memory for the \c data element of the given #ExifEntry.
  /// That memory is freed at the same time as the #ExifEntry.
  ///
  /// \param[out] e entry to initialize
  /// \param[in] tag tag number to initialize as
  void exif_entry_initialize(
    ffi.Pointer<ExifEntry> e,
    int tag,
  ) {
    return _exif_entry_initialize(
      e,
      tag,
    );
  }

  late final _exif_entry_initializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ExifEntry>, ffi.Int32)>>('exif_entry_initialize');
  late final _exif_entry_initialize = _exif_entry_initializePtr
      .asFunction<void Function(ffi.Pointer<ExifEntry>, int)>();

  /// ! Fix the type or format of the given EXIF entry to bring it into spec.
  /// If the data for this EXIF tag is in of the wrong type or is in an invalid
  /// format according to the EXIF specification, then it is converted to make it
  /// valid. This may involve, for example, converting an EXIF_FORMAT_LONG into a
  /// EXIF_FORMAT_SHORT. If the tag is unknown, its value is untouched.
  ///
  /// \note Unfortunately, some conversions are to a type with a more restricted
  /// range, which could have the side effect that the converted data becomes
  /// invalid. This is unlikely as the range of each tag in the standard is
  /// designed to encompass all likely data.
  ///
  /// \param[in,out] entry EXIF entry
  void exif_entry_fix(
    ffi.Pointer<ExifEntry> entry,
  ) {
    return _exif_entry_fix(
      entry,
    );
  }

  late final _exif_entry_fixPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifEntry>)>>(
          'exif_entry_fix');
  late final _exif_entry_fix =
      _exif_entry_fixPtr.asFunction<void Function(ffi.Pointer<ExifEntry>)>();

  /// ! Return a localized textual representation of the value of the EXIF entry.
  /// This is meant for display to the user. The format of each tag is subject
  /// to change between locales and in newer versions of libexif.  Users who
  /// require the tag data in an unambiguous form should access the data members
  /// of the #ExifEntry structure directly.
  ///
  /// \warning The character set of the returned string may be in
  /// the encoding of the current locale or the native encoding
  /// of the camera.
  /// \bug     The EXIF_TAG_XP_* tags are currently always returned in UTF-8,
  /// regardless of locale, and code points above U+FFFF are not
  /// supported.
  ///
  /// \param[in] entry EXIF entry
  /// \param[out] val buffer in which to store value; if entry is valid and
  /// maxlen > 0 then this string will be NUL-terminated
  /// \param[in] maxlen length of the buffer val
  /// \return val pointer
  ffi.Pointer<ffi.Char> exif_entry_get_value(
    ffi.Pointer<ExifEntry> entry,
    ffi.Pointer<ffi.Char> val,
    int maxlen,
  ) {
    return _exif_entry_get_value(
      entry,
      val,
      maxlen,
    );
  }

  late final _exif_entry_get_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ExifEntry>,
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('exif_entry_get_value');
  late final _exif_entry_get_value = _exif_entry_get_valuePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ExifEntry>, ffi.Pointer<ffi.Char>, int)>();

  /// ! Dump text representation of #ExifEntry to stdout.
  /// This is intended for diagnostic purposes only.
  ///
  /// \param[in] entry EXIF tag data
  /// \param[in] indent how many levels deep to indent the data
  void exif_entry_dump(
    ffi.Pointer<ExifEntry> entry,
    int indent,
  ) {
    return _exif_entry_dump(
      entry,
      indent,
    );
  }

  late final _exif_entry_dumpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ExifEntry>, ffi.UnsignedInt)>>('exif_entry_dump');
  late final _exif_entry_dump = _exif_entry_dumpPtr
      .asFunction<void Function(ffi.Pointer<ExifEntry>, int)>();

  /// ! Reserve memory for and initialize a new #ExifContent.
  ///
  /// \return new allocated #ExifContent, or NULL on error
  ///
  /// \see exif_content_new_mem, exif_content_unref
  ffi.Pointer<ExifContent> exif_content_new() {
    return _exif_content_new();
  }

  late final _exif_content_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ExifContent> Function()>>(
          'exif_content_new');
  late final _exif_content_new =
      _exif_content_newPtr.asFunction<ffi.Pointer<ExifContent> Function()>();

  /// ! Reserve memory for and initialize new #ExifContent using the specified
  /// memory allocator.
  ///
  /// \return new allocated #ExifContent, or NULL on error
  ///
  /// \see exif_content_new, exif_content_unref
  ffi.Pointer<ExifContent> exif_content_new_mem(
    ffi.Pointer<ExifMem> arg0,
  ) {
    return _exif_content_new_mem(
      arg0,
    );
  }

  late final _exif_content_new_memPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ExifContent> Function(
              ffi.Pointer<ExifMem>)>>('exif_content_new_mem');
  late final _exif_content_new_mem = _exif_content_new_memPtr
      .asFunction<ffi.Pointer<ExifContent> Function(ffi.Pointer<ExifMem>)>();

  /// ! Increase reference counter for #ExifContent.
  ///
  /// \param[in] content #ExifContent
  ///
  /// \see exif_content_unref
  void exif_content_ref(
    ffi.Pointer<ExifContent> content,
  ) {
    return _exif_content_ref(
      content,
    );
  }

  late final _exif_content_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifContent>)>>(
          'exif_content_ref');
  late final _exif_content_ref = _exif_content_refPtr
      .asFunction<void Function(ffi.Pointer<ExifContent>)>();

  /// ! Decrease reference counter for #ExifContent.
  /// When the reference count drops to zero, free the content.
  ///
  /// \param[in] content #ExifContent
  void exif_content_unref(
    ffi.Pointer<ExifContent> content,
  ) {
    return _exif_content_unref(
      content,
    );
  }

  late final _exif_content_unrefPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifContent>)>>(
          'exif_content_unref');
  late final _exif_content_unref = _exif_content_unrefPtr
      .asFunction<void Function(ffi.Pointer<ExifContent>)>();

  /// ! Actually free the #ExifContent.
  ///
  /// \deprecated Should not be called directly. Use #exif_content_ref and
  /// #exif_content_unref instead.
  ///
  /// \param[in] content #ExifContent
  void exif_content_free(
    ffi.Pointer<ExifContent> content,
  ) {
    return _exif_content_free(
      content,
    );
  }

  late final _exif_content_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifContent>)>>(
          'exif_content_free');
  late final _exif_content_free = _exif_content_freePtr
      .asFunction<void Function(ffi.Pointer<ExifContent>)>();

  /// ! Add an EXIF tag to an IFD.
  /// If this tag already exists in the IFD, this function does nothing.
  /// \pre The "tag" member of the entry must be set on entry.
  ///
  /// \param[out] c IFD
  /// \param[in] entry EXIF entry to add
  void exif_content_add_entry(
    ffi.Pointer<ExifContent> c,
    ffi.Pointer<ExifEntry> entry,
  ) {
    return _exif_content_add_entry(
      c,
      entry,
    );
  }

  late final _exif_content_add_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ExifContent>,
              ffi.Pointer<ExifEntry>)>>('exif_content_add_entry');
  late final _exif_content_add_entry = _exif_content_add_entryPtr.asFunction<
      void Function(ffi.Pointer<ExifContent>, ffi.Pointer<ExifEntry>)>();

  /// ! Remove an EXIF tag from an IFD.
  /// If this tag does not exist in the IFD, this function does nothing.
  ///
  /// \param[out] c IFD
  /// \param[in] e EXIF entry to remove
  void exif_content_remove_entry(
    ffi.Pointer<ExifContent> c,
    ffi.Pointer<ExifEntry> e,
  ) {
    return _exif_content_remove_entry(
      c,
      e,
    );
  }

  late final _exif_content_remove_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ExifContent>,
              ffi.Pointer<ExifEntry>)>>('exif_content_remove_entry');
  late final _exif_content_remove_entry =
      _exif_content_remove_entryPtr.asFunction<
          void Function(ffi.Pointer<ExifContent>, ffi.Pointer<ExifEntry>)>();

  /// ! Return the #ExifEntry in this IFD corresponding to the given tag.
  /// This is a pointer into a member of the #ExifContent array and must NOT be
  /// freed or unrefed by the caller.
  ///
  /// \param[in] content EXIF content for an IFD
  /// \param[in] tag EXIF tag to return
  /// \return #ExifEntry of the tag, or NULL on error
  ffi.Pointer<ExifEntry> exif_content_get_entry(
    ffi.Pointer<ExifContent> content,
    int tag,
  ) {
    return _exif_content_get_entry(
      content,
      tag,
    );
  }

  late final _exif_content_get_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ExifEntry> Function(
              ffi.Pointer<ExifContent>, ffi.Int32)>>('exif_content_get_entry');
  late final _exif_content_get_entry = _exif_content_get_entryPtr.asFunction<
      ffi.Pointer<ExifEntry> Function(ffi.Pointer<ExifContent>, int)>();

  /// ! Fix the IFD to bring it into specification. Call #exif_entry_fix on
  /// each entry in this IFD to fix existing entries, create any new entries
  /// that are mandatory in this IFD but do not yet exist, and remove any
  /// entries that are not allowed in this IFD.
  ///
  /// \param[in,out] c EXIF content for an IFD
  void exif_content_fix(
    ffi.Pointer<ExifContent> c,
  ) {
    return _exif_content_fix(
      c,
    );
  }

  late final _exif_content_fixPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifContent>)>>(
          'exif_content_fix');
  late final _exif_content_fix = _exif_content_fixPtr
      .asFunction<void Function(ffi.Pointer<ExifContent>)>();

  /// ! Executes function on each EXIF tag in this IFD in turn.
  /// The tags will not necessarily be visited in numerical order.
  ///
  /// \param[in,out] content IFD over which to iterate
  /// \param[in] func function to call for each entry
  /// \param[in] user_data data to pass into func on each call
  void exif_content_foreach_entry(
    ffi.Pointer<ExifContent> content,
    ExifContentForeachEntryFunc func,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _exif_content_foreach_entry(
      content,
      func,
      user_data,
    );
  }

  late final _exif_content_foreach_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ExifContent>,
              ExifContentForeachEntryFunc,
              ffi.Pointer<ffi.Void>)>>('exif_content_foreach_entry');
  late final _exif_content_foreach_entry =
      _exif_content_foreach_entryPtr.asFunction<
          void Function(ffi.Pointer<ExifContent>, ExifContentForeachEntryFunc,
              ffi.Pointer<ffi.Void>)>();

  /// ! Return the IFD number in which the given #ExifContent is found.
  ///
  /// \param[in] c an #ExifContent*
  /// \return IFD number, or #EXIF_IFD_COUNT on error
  int exif_content_get_ifd(
    ffi.Pointer<ExifContent> c,
  ) {
    return _exif_content_get_ifd(
      c,
    );
  }

  late final _exif_content_get_ifdPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ExifContent>)>>(
          'exif_content_get_ifd');
  late final _exif_content_get_ifd = _exif_content_get_ifdPtr
      .asFunction<int Function(ffi.Pointer<ExifContent>)>();

  /// ! Dump contents of the IFD to stdout.
  /// This is intended for diagnostic purposes only.
  ///
  /// \param[in] content IFD data
  /// \param[in] indent how many levels deep to indent the data
  void exif_content_dump(
    ffi.Pointer<ExifContent> content,
    int indent,
  ) {
    return _exif_content_dump(
      content,
      indent,
    );
  }

  late final _exif_content_dumpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ExifContent>, ffi.UnsignedInt)>>('exif_content_dump');
  late final _exif_content_dump = _exif_content_dumpPtr
      .asFunction<void Function(ffi.Pointer<ExifContent>, int)>();

  /// ! Set the log message object for this IFD.
  ///
  /// \param[in] content IFD
  /// \param[in] log #ExifLog*
  void exif_content_log(
    ffi.Pointer<ExifContent> content,
    ffi.Pointer<ExifLog> log,
  ) {
    return _exif_content_log(
      content,
      log,
    );
  }

  late final _exif_content_logPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ExifContent>,
              ffi.Pointer<ExifLog>)>>('exif_content_log');
  late final _exif_content_log = _exif_content_logPtr.asFunction<
      void Function(ffi.Pointer<ExifContent>, ffi.Pointer<ExifLog>)>();

  void exif_mnote_data_ref(
    ffi.Pointer<ExifMnoteData> arg0,
  ) {
    return _exif_mnote_data_ref(
      arg0,
    );
  }

  late final _exif_mnote_data_refPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifMnoteData>)>>(
      'exif_mnote_data_ref');
  late final _exif_mnote_data_ref = _exif_mnote_data_refPtr
      .asFunction<void Function(ffi.Pointer<ExifMnoteData>)>();

  void exif_mnote_data_unref(
    ffi.Pointer<ExifMnoteData> arg0,
  ) {
    return _exif_mnote_data_unref(
      arg0,
    );
  }

  late final _exif_mnote_data_unrefPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifMnoteData>)>>(
      'exif_mnote_data_unref');
  late final _exif_mnote_data_unref = _exif_mnote_data_unrefPtr
      .asFunction<void Function(ffi.Pointer<ExifMnoteData>)>();

  /// ! Load the MakerNote data from a memory buffer.
  ///
  /// \param[in] d MakerNote data
  /// \param[in] buf pointer to raw MakerNote tag data
  /// \param[in] buf_size number of bytes of data at buf
  void exif_mnote_data_load(
    ffi.Pointer<ExifMnoteData> d,
    ffi.Pointer<ffi.UnsignedChar> buf,
    int buf_size,
  ) {
    return _exif_mnote_data_load(
      d,
      buf,
      buf_size,
    );
  }

  late final _exif_mnote_data_loadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ExifMnoteData>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedInt)>>('exif_mnote_data_load');
  late final _exif_mnote_data_load = _exif_mnote_data_loadPtr.asFunction<
      void Function(
          ffi.Pointer<ExifMnoteData>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// !
  /// Save the raw MakerNote data into a memory buffer.  The buffer is
  /// allocated by this function and must subsequently be freed by the
  /// caller.
  ///
  /// \param[in,out] d extract the data from this structure
  /// \param[out] buf pointer to buffer pointer containing MakerNote data on return
  /// \param[out] buf_size pointer to the size of the buffer
  void exif_mnote_data_save(
    ffi.Pointer<ExifMnoteData> d,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> buf,
    ffi.Pointer<ffi.UnsignedInt> buf_size,
  ) {
    return _exif_mnote_data_save(
      d,
      buf,
      buf_size,
    );
  }

  late final _exif_mnote_data_savePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ExifMnoteData>,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.UnsignedInt>)>>('exif_mnote_data_save');
  late final _exif_mnote_data_save = _exif_mnote_data_savePtr.asFunction<
      void Function(
          ffi.Pointer<ExifMnoteData>,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// ! Return the number of tags in the MakerNote.
  ///
  /// \param[in] d MakerNote data
  /// \return number of tags, or 0 if no MakerNote or the type is not supported
  int exif_mnote_data_count(
    ffi.Pointer<ExifMnoteData> d,
  ) {
    return _exif_mnote_data_count(
      d,
    );
  }

  late final _exif_mnote_data_countPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<ExifMnoteData>)>>('exif_mnote_data_count');
  late final _exif_mnote_data_count = _exif_mnote_data_countPtr
      .asFunction<int Function(ffi.Pointer<ExifMnoteData>)>();

  /// ! Return the MakerNote tag number for the tag at the specified index within
  /// the MakerNote.
  ///
  /// \param[in] d MakerNote data
  /// \param[in] n index of the entry within the MakerNote data
  /// \return MakerNote tag number
  int exif_mnote_data_get_id(
    ffi.Pointer<ExifMnoteData> d,
    int n,
  ) {
    return _exif_mnote_data_get_id(
      d,
      n,
    );
  }

  late final _exif_mnote_data_get_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<ExifMnoteData>,
              ffi.UnsignedInt)>>('exif_mnote_data_get_id');
  late final _exif_mnote_data_get_id = _exif_mnote_data_get_idPtr
      .asFunction<int Function(ffi.Pointer<ExifMnoteData>, int)>();

  /// ! Returns textual name of the given MakerNote tag. The name is a short,
  /// unique (within this type of MakerNote), non-localized text string
  /// containing only US-ASCII alphanumeric characters.
  ///
  /// \param[in] d MakerNote data
  /// \param[in] n index of the entry within the MakerNote data
  /// \return textual name of the tag or NULL on error
  ffi.Pointer<ffi.Char> exif_mnote_data_get_name(
    ffi.Pointer<ExifMnoteData> d,
    int n,
  ) {
    return _exif_mnote_data_get_name(
      d,
      n,
    );
  }

  late final _exif_mnote_data_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ExifMnoteData>,
              ffi.UnsignedInt)>>('exif_mnote_data_get_name');
  late final _exif_mnote_data_get_name =
      _exif_mnote_data_get_namePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ExifMnoteData>, int)>();

  /// ! Returns textual title of the given MakerNote tag.
  /// The title is a short, localized textual description of the tag.
  ///
  /// \param[in] d MakerNote data
  /// \param[in] n index of the entry within the MakerNote data
  /// \return textual name of the tag or NULL on error
  ffi.Pointer<ffi.Char> exif_mnote_data_get_title(
    ffi.Pointer<ExifMnoteData> d,
    int n,
  ) {
    return _exif_mnote_data_get_title(
      d,
      n,
    );
  }

  late final _exif_mnote_data_get_titlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ExifMnoteData>,
              ffi.UnsignedInt)>>('exif_mnote_data_get_title');
  late final _exif_mnote_data_get_title =
      _exif_mnote_data_get_titlePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ExifMnoteData>, int)>();

  /// ! Returns verbose textual description of the given MakerNote tag.
  ///
  /// \param[in] d MakerNote data
  /// \param[in] n index of the entry within the MakerNote data
  /// \return textual description of the tag or NULL on error
  ffi.Pointer<ffi.Char> exif_mnote_data_get_description(
    ffi.Pointer<ExifMnoteData> d,
    int n,
  ) {
    return _exif_mnote_data_get_description(
      d,
      n,
    );
  }

  late final _exif_mnote_data_get_descriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ExifMnoteData>,
              ffi.UnsignedInt)>>('exif_mnote_data_get_description');
  late final _exif_mnote_data_get_description =
      _exif_mnote_data_get_descriptionPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ExifMnoteData>, int)>();

  /// ! Return a textual representation of the value of the MakerNote entry.
  ///
  /// \warning The character set of the returned string may be in
  /// the encoding of the current locale or the native encoding
  /// of the camera.
  ///
  /// \param[in] d MakerNote data
  /// \param[in] n index of the entry within the MakerNote data
  /// \param[out] val buffer in which to store value
  /// \param[in] maxlen length of the buffer val
  /// \return val pointer, or NULL on error
  ffi.Pointer<ffi.Char> exif_mnote_data_get_value(
    ffi.Pointer<ExifMnoteData> d,
    int n,
    ffi.Pointer<ffi.Char> val,
    int maxlen,
  ) {
    return _exif_mnote_data_get_value(
      d,
      n,
      val,
      maxlen,
    );
  }

  late final _exif_mnote_data_get_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ExifMnoteData>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('exif_mnote_data_get_value');
  late final _exif_mnote_data_get_value =
      _exif_mnote_data_get_valuePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ExifMnoteData>, int, ffi.Pointer<ffi.Char>, int)>();

  void exif_mnote_data_log(
    ffi.Pointer<ExifMnoteData> arg0,
    ffi.Pointer<ExifLog> arg1,
  ) {
    return _exif_mnote_data_log(
      arg0,
      arg1,
    );
  }

  late final _exif_mnote_data_logPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ExifMnoteData>,
              ffi.Pointer<ExifLog>)>>('exif_mnote_data_log');
  late final _exif_mnote_data_log = _exif_mnote_data_logPtr.asFunction<
      void Function(ffi.Pointer<ExifMnoteData>, ffi.Pointer<ExifLog>)>();

  /// ! Allocate a new #ExifData. The #ExifData contains an empty
  /// #ExifContent for each IFD and the default set of options,
  /// which has #EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS
  /// and #EXIF_DATA_OPTION_FOLLOW_SPECIFICATION set.
  ///
  /// \return allocated #ExifData, or NULL on error
  ffi.Pointer<ExifData> exif_data_new() {
    return _exif_data_new();
  }

  late final _exif_data_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ExifData> Function()>>(
          'exif_data_new');
  late final _exif_data_new =
      _exif_data_newPtr.asFunction<ffi.Pointer<ExifData> Function()>();

  /// ! Allocate a new #ExifData using the given memory allocator.
  /// The #ExifData contains an empty #ExifContent for each IFD and the default
  /// set of options, which has #EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS and
  /// #EXIF_DATA_OPTION_FOLLOW_SPECIFICATION set.
  ///
  /// \return allocated #ExifData, or NULL on error
  ffi.Pointer<ExifData> exif_data_new_mem(
    ffi.Pointer<ExifMem> arg0,
  ) {
    return _exif_data_new_mem(
      arg0,
    );
  }

  late final _exif_data_new_memPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ExifData> Function(
              ffi.Pointer<ExifMem>)>>('exif_data_new_mem');
  late final _exif_data_new_mem = _exif_data_new_memPtr
      .asFunction<ffi.Pointer<ExifData> Function(ffi.Pointer<ExifMem>)>();

  /// ! Allocate a new #ExifData and load EXIF data from a JPEG file.
  /// Uses an #ExifLoader internally to do the loading.
  ///
  /// \param[in] path filename including path
  /// \return allocated #ExifData, or NULL on error
  ffi.Pointer<ExifData> exif_data_new_from_file(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _exif_data_new_from_file(
      path,
    );
  }

  late final _exif_data_new_from_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ExifData> Function(
              ffi.Pointer<ffi.Char>)>>('exif_data_new_from_file');
  late final _exif_data_new_from_file = _exif_data_new_from_filePtr
      .asFunction<ffi.Pointer<ExifData> Function(ffi.Pointer<ffi.Char>)>();

  /// ! Allocate a new #ExifData and load EXIF data from a memory buffer.
  ///
  /// \param[in] data pointer to raw JPEG or EXIF data
  /// \param[in] size number of bytes of data at data
  /// \return allocated #ExifData, or NULL on error
  ffi.Pointer<ExifData> exif_data_new_from_data(
    ffi.Pointer<ffi.UnsignedChar> data,
    int size,
  ) {
    return _exif_data_new_from_data(
      data,
      size,
    );
  }

  late final _exif_data_new_from_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ExifData> Function(ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedInt)>>('exif_data_new_from_data');
  late final _exif_data_new_from_data = _exif_data_new_from_dataPtr.asFunction<
      ffi.Pointer<ExifData> Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// ! Load the #ExifData structure from the raw JPEG or EXIF data in the given
  /// memory buffer. If the EXIF data contains a recognized MakerNote, it is
  /// loaded and stored as well for later retrieval by #exif_data_get_mnote_data.
  /// If the #EXIF_DATA_OPTION_FOLLOW_SPECIFICATION option has been set on this
  /// #ExifData, then the tags are automatically fixed after loading (by calling
  /// #exif_data_fix).
  ///
  /// \param[in,out] data EXIF data
  /// \param[in] d pointer to raw JPEG or EXIF data
  /// \param[in] size number of bytes of data at d
  void exif_data_load_data(
    ffi.Pointer<ExifData> data,
    ffi.Pointer<ffi.UnsignedChar> d,
    int size,
  ) {
    return _exif_data_load_data(
      data,
      d,
      size,
    );
  }

  late final _exif_data_load_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ExifData>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedInt)>>('exif_data_load_data');
  late final _exif_data_load_data = _exif_data_load_dataPtr.asFunction<
      void Function(
          ffi.Pointer<ExifData>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// ! Store raw EXIF data representing the #ExifData structure into a memory
  /// buffer. The buffer is allocated by this function and must subsequently be
  /// freed by the caller using the matching free function as used by the #ExifMem
  /// in use by this #ExifData.
  ///
  /// \param[in] data EXIF data
  /// \param[out] d pointer to buffer pointer containing raw EXIF data on return
  /// \param[out] ds pointer to variable to hold the number of bytes of
  /// data at d, or set to 0 on error
  void exif_data_save_data(
    ffi.Pointer<ExifData> data,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> d,
    ffi.Pointer<ffi.UnsignedInt> ds,
  ) {
    return _exif_data_save_data(
      data,
      d,
      ds,
    );
  }

  late final _exif_data_save_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ExifData>,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.UnsignedInt>)>>('exif_data_save_data');
  late final _exif_data_save_data = _exif_data_save_dataPtr.asFunction<
      void Function(
          ffi.Pointer<ExifData>,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  void exif_data_ref(
    ffi.Pointer<ExifData> data,
  ) {
    return _exif_data_ref(
      data,
    );
  }

  late final _exif_data_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifData>)>>(
          'exif_data_ref');
  late final _exif_data_ref =
      _exif_data_refPtr.asFunction<void Function(ffi.Pointer<ExifData>)>();

  void exif_data_unref(
    ffi.Pointer<ExifData> data,
  ) {
    return _exif_data_unref(
      data,
    );
  }

  late final _exif_data_unrefPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifData>)>>(
          'exif_data_unref');
  late final _exif_data_unref =
      _exif_data_unrefPtr.asFunction<void Function(ffi.Pointer<ExifData>)>();

  void exif_data_free(
    ffi.Pointer<ExifData> data,
  ) {
    return _exif_data_free(
      data,
    );
  }

  late final _exif_data_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifData>)>>(
          'exif_data_free');
  late final _exif_data_free =
      _exif_data_freePtr.asFunction<void Function(ffi.Pointer<ExifData>)>();

  /// ! Return the byte order in use by this EXIF structure.
  ///
  /// \param[in] data EXIF data
  /// \return byte order
  int exif_data_get_byte_order(
    ffi.Pointer<ExifData> data,
  ) {
    return _exif_data_get_byte_order(
      data,
    );
  }

  late final _exif_data_get_byte_orderPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ExifData>)>>(
          'exif_data_get_byte_order');
  late final _exif_data_get_byte_order = _exif_data_get_byte_orderPtr
      .asFunction<int Function(ffi.Pointer<ExifData>)>();

  /// ! Set the byte order to use for this EXIF data. If any tags already exist
  /// (including MakerNote tags) they are are converted to the specified byte
  /// order.
  ///
  /// \param[in,out] data EXIF data
  /// \param[in] order byte order
  void exif_data_set_byte_order(
    ffi.Pointer<ExifData> data,
    int order,
  ) {
    return _exif_data_set_byte_order(
      data,
      order,
    );
  }

  late final _exif_data_set_byte_orderPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ExifData>, ffi.Int32)>>(
      'exif_data_set_byte_order');
  late final _exif_data_set_byte_order = _exif_data_set_byte_orderPtr
      .asFunction<void Function(ffi.Pointer<ExifData>, int)>();

  /// ! Return the MakerNote data out of the EXIF data.  Only certain
  /// MakerNote formats that are recognized by libexif are supported.
  /// The pointer references a member of the #ExifData structure and must NOT be
  /// freed by the caller.
  ///
  /// \param[in] d EXIF data
  /// \return MakerNote data, or NULL if not found or not supported
  ffi.Pointer<ExifMnoteData> exif_data_get_mnote_data(
    ffi.Pointer<ExifData> d,
  ) {
    return _exif_data_get_mnote_data(
      d,
    );
  }

  late final _exif_data_get_mnote_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ExifMnoteData> Function(
              ffi.Pointer<ExifData>)>>('exif_data_get_mnote_data');
  late final _exif_data_get_mnote_data = _exif_data_get_mnote_dataPtr
      .asFunction<ffi.Pointer<ExifMnoteData> Function(ffi.Pointer<ExifData>)>();

  /// ! Fix the EXIF data to bring it into specification. Call #exif_content_fix
  /// on each IFD to fix existing entries, create any new entries that are
  /// mandatory but do not yet exist, and remove any entries that are not
  /// allowed.
  ///
  /// \param[in,out] d EXIF data
  void exif_data_fix(
    ffi.Pointer<ExifData> d,
  ) {
    return _exif_data_fix(
      d,
    );
  }

  late final _exif_data_fixPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifData>)>>(
          'exif_data_fix');
  late final _exif_data_fix =
      _exif_data_fixPtr.asFunction<void Function(ffi.Pointer<ExifData>)>();

  /// ! Execute a function on each IFD in turn.
  ///
  /// \param[in] data EXIF data over which to iterate
  /// \param[in] func function to call for each entry
  /// \param[in] user_data data to pass into func on each call
  void exif_data_foreach_content(
    ffi.Pointer<ExifData> data,
    ExifDataForeachContentFunc func,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _exif_data_foreach_content(
      data,
      func,
      user_data,
    );
  }

  late final _exif_data_foreach_contentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ExifData>, ExifDataForeachContentFunc,
              ffi.Pointer<ffi.Void>)>>('exif_data_foreach_content');
  late final _exif_data_foreach_content =
      _exif_data_foreach_contentPtr.asFunction<
          void Function(ffi.Pointer<ExifData>, ExifDataForeachContentFunc,
              ffi.Pointer<ffi.Void>)>();

  /// ! Return a short textual description of the given #ExifDataOption.
  ///
  /// \param[in] o option
  /// \return localized textual description of the option,
  /// or NULL if unknown
  ffi.Pointer<ffi.Char> exif_data_option_get_name(
    int o,
  ) {
    return _exif_data_option_get_name(
      o,
    );
  }

  late final _exif_data_option_get_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'exif_data_option_get_name');
  late final _exif_data_option_get_name = _exif_data_option_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! Return a verbose textual description of the given #ExifDataOption.
  ///
  /// \param[in] o option
  /// \return verbose localized textual description of the option,
  /// or NULL if unknown
  ffi.Pointer<ffi.Char> exif_data_option_get_description(
    int o,
  ) {
    return _exif_data_option_get_description(
      o,
    );
  }

  late final _exif_data_option_get_descriptionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'exif_data_option_get_description');
  late final _exif_data_option_get_description =
      _exif_data_option_get_descriptionPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! Set the given option on the given #ExifData.
  ///
  /// \param[in] d EXIF data
  /// \param[in] o option
  void exif_data_set_option(
    ffi.Pointer<ExifData> d,
    int o,
  ) {
    return _exif_data_set_option(
      d,
      o,
    );
  }

  late final _exif_data_set_optionPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ExifData>, ffi.Int32)>>(
      'exif_data_set_option');
  late final _exif_data_set_option = _exif_data_set_optionPtr
      .asFunction<void Function(ffi.Pointer<ExifData>, int)>();

  /// ! Clear the given option on the given #ExifData.
  ///
  /// \param[in] d EXIF data
  /// \param[in] o option
  void exif_data_unset_option(
    ffi.Pointer<ExifData> d,
    int o,
  ) {
    return _exif_data_unset_option(
      d,
      o,
    );
  }

  late final _exif_data_unset_optionPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ExifData>, ffi.Int32)>>(
      'exif_data_unset_option');
  late final _exif_data_unset_option = _exif_data_unset_optionPtr
      .asFunction<void Function(ffi.Pointer<ExifData>, int)>();

  /// ! Set the data type for the given #ExifData.
  ///
  /// \param[in] d EXIF data
  /// \param[in] dt data type
  void exif_data_set_data_type(
    ffi.Pointer<ExifData> d,
    int dt,
  ) {
    return _exif_data_set_data_type(
      d,
      dt,
    );
  }

  late final _exif_data_set_data_typePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ExifData>, ffi.Int32)>>(
      'exif_data_set_data_type');
  late final _exif_data_set_data_type = _exif_data_set_data_typePtr
      .asFunction<void Function(ffi.Pointer<ExifData>, int)>();

  /// ! Return the data type for the given #ExifData.
  ///
  /// \param[in] d EXIF data
  /// \return data type, or #EXIF_DATA_TYPE_UNKNOWN on error
  int exif_data_get_data_type(
    ffi.Pointer<ExifData> d,
  ) {
    return _exif_data_get_data_type(
      d,
    );
  }

  late final _exif_data_get_data_typePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ExifData>)>>(
          'exif_data_get_data_type');
  late final _exif_data_get_data_type = _exif_data_get_data_typePtr
      .asFunction<int Function(ffi.Pointer<ExifData>)>();

  /// ! Dump all EXIF data to stdout.
  /// This is intended for diagnostic purposes only.
  ///
  /// \param[in] data EXIF data
  void exif_data_dump(
    ffi.Pointer<ExifData> data,
  ) {
    return _exif_data_dump(
      data,
    );
  }

  late final _exif_data_dumpPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifData>)>>(
          'exif_data_dump');
  late final _exif_data_dump =
      _exif_data_dumpPtr.asFunction<void Function(ffi.Pointer<ExifData>)>();

  /// ! Set the log message object for all IFDs.
  ///
  /// \param[in] data EXIF data
  /// \param[in] log #ExifLog
  void exif_data_log(
    ffi.Pointer<ExifData> data,
    ffi.Pointer<ExifLog> log,
  ) {
    return _exif_data_log(
      data,
      log,
    );
  }

  late final _exif_data_logPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ExifData>, ffi.Pointer<ExifLog>)>>('exif_data_log');
  late final _exif_data_log = _exif_data_logPtr
      .asFunction<void Function(ffi.Pointer<ExifData>, ffi.Pointer<ExifLog>)>();

  /// ! \internal
  void exif_mnote_data_construct(
    ffi.Pointer<ExifMnoteData> arg0,
    ffi.Pointer<ExifMem> mem,
  ) {
    return _exif_mnote_data_construct(
      arg0,
      mem,
    );
  }

  late final _exif_mnote_data_constructPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ExifMnoteData>,
              ffi.Pointer<ExifMem>)>>('exif_mnote_data_construct');
  late final _exif_mnote_data_construct =
      _exif_mnote_data_constructPtr.asFunction<
          void Function(ffi.Pointer<ExifMnoteData>, ffi.Pointer<ExifMem>)>();

  /// ! \internal
  void exif_mnote_data_set_byte_order(
    ffi.Pointer<ExifMnoteData> arg0,
    int arg1,
  ) {
    return _exif_mnote_data_set_byte_order(
      arg0,
      arg1,
    );
  }

  late final _exif_mnote_data_set_byte_orderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ExifMnoteData>,
              ffi.Int32)>>('exif_mnote_data_set_byte_order');
  late final _exif_mnote_data_set_byte_order =
      _exif_mnote_data_set_byte_orderPtr
          .asFunction<void Function(ffi.Pointer<ExifMnoteData>, int)>();

  /// ! \internal
  void exif_mnote_data_set_offset(
    ffi.Pointer<ExifMnoteData> arg0,
    int arg1,
  ) {
    return _exif_mnote_data_set_offset(
      arg0,
      arg1,
    );
  }

  late final _exif_mnote_data_set_offsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ExifMnoteData>,
              ffi.UnsignedInt)>>('exif_mnote_data_set_offset');
  late final _exif_mnote_data_set_offset = _exif_mnote_data_set_offsetPtr
      .asFunction<void Function(ffi.Pointer<ExifMnoteData>, int)>();

  ffi.Pointer<ffi.Char> mnote_apple_entry_get_value(
    ffi.Pointer<MnoteAppleEntry> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _mnote_apple_entry_get_value(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _mnote_apple_entry_get_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MnoteAppleEntry>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('mnote_apple_entry_get_value');
  late final _mnote_apple_entry_get_value =
      _mnote_apple_entry_get_valuePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MnoteAppleEntry>, ffi.Pointer<ffi.Char>, int)>();

  int exif_mnote_data_apple_identify(
    ffi.Pointer<ExifData> arg0,
    ffi.Pointer<ExifEntry> arg1,
  ) {
    return _exif_mnote_data_apple_identify(
      arg0,
      arg1,
    );
  }

  late final _exif_mnote_data_apple_identifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ExifData>,
              ffi.Pointer<ExifEntry>)>>('exif_mnote_data_apple_identify');
  late final _exif_mnote_data_apple_identify =
      _exif_mnote_data_apple_identifyPtr.asFunction<
          int Function(ffi.Pointer<ExifData>, ffi.Pointer<ExifEntry>)>();

  ffi.Pointer<ExifMnoteData> exif_mnote_data_apple_new(
    ffi.Pointer<ExifMem> arg0,
  ) {
    return _exif_mnote_data_apple_new(
      arg0,
    );
  }

  late final _exif_mnote_data_apple_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ExifMnoteData> Function(
              ffi.Pointer<ExifMem>)>>('exif_mnote_data_apple_new');
  late final _exif_mnote_data_apple_new = _exif_mnote_data_apple_newPtr
      .asFunction<ffi.Pointer<ExifMnoteData> Function(ffi.Pointer<ExifMem>)>();

  /// ! Return a textual name of the given tag within the Olympus-style MakerNote.
  /// The name is a short, unique, non-localized text string containing only
  /// US-ASCII alphanumeric characters.
  ///
  /// \param[in] tag Olympus-style MakerNote tag
  /// \return textual name of the tag, or NULL if the tag is unknown
  ffi.Pointer<ffi.Char> mnote_olympus_tag_get_name(
    int tag,
  ) {
    return _mnote_olympus_tag_get_name(
      tag,
    );
  }

  late final _mnote_olympus_tag_get_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'mnote_olympus_tag_get_name');
  late final _mnote_olympus_tag_get_name = _mnote_olympus_tag_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! Return a textual title of the given tag within the Olympus-style MakerNote.
  /// The title is a short, localized description of the tag.
  ///
  /// \param[in] tag Olympus-style MakerNote tag
  /// \return textual title of the tag, or NULL if the tag is unknown
  ffi.Pointer<ffi.Char> mnote_olympus_tag_get_title(
    int tag,
  ) {
    return _mnote_olympus_tag_get_title(
      tag,
    );
  }

  late final _mnote_olympus_tag_get_titlePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'mnote_olympus_tag_get_title');
  late final _mnote_olympus_tag_get_title = _mnote_olympus_tag_get_titlePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! Return a verbose textual description of the given tag within the
  /// Olympus-style MakerNote.
  /// The description is a verbose, localized description of the tag.
  ///
  /// \param[in] tag EXIF tag
  /// \return textual description of the tag, or NULL if the tag is unknown
  ffi.Pointer<ffi.Char> mnote_olympus_tag_get_description(
    int tag,
  ) {
    return _mnote_olympus_tag_get_description(
      tag,
    );
  }

  late final _mnote_olympus_tag_get_descriptionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'mnote_olympus_tag_get_description');
  late final _mnote_olympus_tag_get_description =
      _mnote_olympus_tag_get_descriptionPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<ffi.Char> mnote_olympus_entry_get_value(
    ffi.Pointer<MnoteOlympusEntry> entry,
    ffi.Pointer<ffi.Char> val,
    int maxlen,
  ) {
    return _mnote_olympus_entry_get_value(
      entry,
      val,
      maxlen,
    );
  }

  late final _mnote_olympus_entry_get_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MnoteOlympusEntry>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('mnote_olympus_entry_get_value');
  late final _mnote_olympus_entry_get_value =
      _mnote_olympus_entry_get_valuePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MnoteOlympusEntry>, ffi.Pointer<ffi.Char>, int)>();

  /// ! Detect if MakerNote is recognized as one handled by the Olympus module.
  ///
  /// \param[in] ed image #ExifData to identify as as an Olympus type
  /// \param[in] e #ExifEntry for EXIF_TAG_MAKER_NOTE, from within ed but
  /// duplicated here for convenience
  /// \return 0 if not recognized, nonzero if recognized. The specific nonzero
  /// value returned may identify a subtype unique within this module.
  int exif_mnote_data_olympus_identify(
    ffi.Pointer<ExifData> ed,
    ffi.Pointer<ExifEntry> e,
  ) {
    return _exif_mnote_data_olympus_identify(
      ed,
      e,
    );
  }

  late final _exif_mnote_data_olympus_identifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ExifData>,
              ffi.Pointer<ExifEntry>)>>('exif_mnote_data_olympus_identify');
  late final _exif_mnote_data_olympus_identify =
      _exif_mnote_data_olympus_identifyPtr.asFunction<
          int Function(ffi.Pointer<ExifData>, ffi.Pointer<ExifEntry>)>();

  ffi.Pointer<ExifMnoteData> exif_mnote_data_olympus_new(
    ffi.Pointer<ExifMem> arg0,
  ) {
    return _exif_mnote_data_olympus_new(
      arg0,
    );
  }

  late final _exif_mnote_data_olympus_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ExifMnoteData> Function(
              ffi.Pointer<ExifMem>)>>('exif_mnote_data_olympus_new');
  late final _exif_mnote_data_olympus_new = _exif_mnote_data_olympus_newPtr
      .asFunction<ffi.Pointer<ExifMnoteData> Function(ffi.Pointer<ExifMem>)>();

  ffi.Pointer<ffi.Char> mnote_fuji_tag_get_name(
    int tag,
  ) {
    return _mnote_fuji_tag_get_name(
      tag,
    );
  }

  late final _mnote_fuji_tag_get_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'mnote_fuji_tag_get_name');
  late final _mnote_fuji_tag_get_name = _mnote_fuji_tag_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<ffi.Char> mnote_fuji_tag_get_title(
    int tag,
  ) {
    return _mnote_fuji_tag_get_title(
      tag,
    );
  }

  late final _mnote_fuji_tag_get_titlePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'mnote_fuji_tag_get_title');
  late final _mnote_fuji_tag_get_title = _mnote_fuji_tag_get_titlePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<ffi.Char> mnote_fuji_tag_get_description(
    int tag,
  ) {
    return _mnote_fuji_tag_get_description(
      tag,
    );
  }

  late final _mnote_fuji_tag_get_descriptionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'mnote_fuji_tag_get_description');
  late final _mnote_fuji_tag_get_description =
      _mnote_fuji_tag_get_descriptionPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! Detect if MakerNote is recognized as one handled by the Fuji module.
  ///
  /// \param[in] ed image #ExifData to identify as as a Fuji type
  /// \param[in] e #ExifEntry for EXIF_TAG_MAKER_NOTE, from within ed but
  /// duplicated here for convenience
  /// \return 0 if not recognized, nonzero if recognized. The specific nonzero
  /// value returned may identify a subtype unique within this module.
  int exif_mnote_data_fuji_identify(
    ffi.Pointer<ExifData> ed,
    ffi.Pointer<ExifEntry> e,
  ) {
    return _exif_mnote_data_fuji_identify(
      ed,
      e,
    );
  }

  late final _exif_mnote_data_fuji_identifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ExifData>,
              ffi.Pointer<ExifEntry>)>>('exif_mnote_data_fuji_identify');
  late final _exif_mnote_data_fuji_identify =
      _exif_mnote_data_fuji_identifyPtr.asFunction<
          int Function(ffi.Pointer<ExifData>, ffi.Pointer<ExifEntry>)>();

  ffi.Pointer<ExifMnoteData> exif_mnote_data_fuji_new(
    ffi.Pointer<ExifMem> arg0,
  ) {
    return _exif_mnote_data_fuji_new(
      arg0,
    );
  }

  late final _exif_mnote_data_fuji_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ExifMnoteData> Function(
              ffi.Pointer<ExifMem>)>>('exif_mnote_data_fuji_new');
  late final _exif_mnote_data_fuji_new = _exif_mnote_data_fuji_newPtr
      .asFunction<ffi.Pointer<ExifMnoteData> Function(ffi.Pointer<ExifMem>)>();

  ffi.Pointer<ffi.Char> mnote_fuji_entry_get_value(
    ffi.Pointer<MnoteFujiEntry> entry,
    ffi.Pointer<ffi.Char> val,
    int maxlen,
  ) {
    return _mnote_fuji_entry_get_value(
      entry,
      val,
      maxlen,
    );
  }

  late final _mnote_fuji_entry_get_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MnoteFujiEntry>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('mnote_fuji_entry_get_value');
  late final _mnote_fuji_entry_get_value =
      _mnote_fuji_entry_get_valuePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MnoteFujiEntry>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ExifGPSIfdTagInfo> exif_get_gps_tag_info(
    int tag,
  ) {
    return _exif_get_gps_tag_info(
      tag,
    );
  }

  late final _exif_get_gps_tag_infoPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<ExifGPSIfdTagInfo> Function(ffi.Int32)>>(
      'exif_get_gps_tag_info');
  late final _exif_get_gps_tag_info = _exif_get_gps_tag_infoPtr
      .asFunction<ffi.Pointer<ExifGPSIfdTagInfo> Function(int)>();

  /// ! Allocate a new #ExifLoader.
  ///
  /// \return allocated ExifLoader
  ffi.Pointer<ExifLoader> exif_loader_new() {
    return _exif_loader_new();
  }

  late final _exif_loader_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ExifLoader> Function()>>(
          'exif_loader_new');
  late final _exif_loader_new =
      _exif_loader_newPtr.asFunction<ffi.Pointer<ExifLoader> Function()>();

  /// ! Allocate a new #ExifLoader using the specified memory allocator.
  ///
  /// \param[in] mem the ExifMem
  /// \return allocated ExifLoader
  ffi.Pointer<ExifLoader> exif_loader_new_mem(
    ffi.Pointer<ExifMem> mem,
  ) {
    return _exif_loader_new_mem(
      mem,
    );
  }

  late final _exif_loader_new_memPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ExifLoader> Function(
              ffi.Pointer<ExifMem>)>>('exif_loader_new_mem');
  late final _exif_loader_new_mem = _exif_loader_new_memPtr
      .asFunction<ffi.Pointer<ExifLoader> Function(ffi.Pointer<ExifMem>)>();

  /// ! Increase the refcount of the #ExifLoader.
  ///
  /// \param[in] loader the ExifLoader to increase the refcount of.
  void exif_loader_ref(
    ffi.Pointer<ExifLoader> loader,
  ) {
    return _exif_loader_ref(
      loader,
    );
  }

  late final _exif_loader_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifLoader>)>>(
          'exif_loader_ref');
  late final _exif_loader_ref =
      _exif_loader_refPtr.asFunction<void Function(ffi.Pointer<ExifLoader>)>();

  /// ! Decrease the refcount of the #ExifLoader.
  /// If the refcount reaches 0, the loader is freed.
  ///
  /// \param[in] loader ExifLoader for which to decrease the refcount
  void exif_loader_unref(
    ffi.Pointer<ExifLoader> loader,
  ) {
    return _exif_loader_unref(
      loader,
    );
  }

  late final _exif_loader_unrefPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifLoader>)>>(
          'exif_loader_unref');
  late final _exif_loader_unref = _exif_loader_unrefPtr
      .asFunction<void Function(ffi.Pointer<ExifLoader>)>();

  /// ! Load a file into the given #ExifLoader from the filesystem.
  /// The relevant data is copied in raw form into the #ExifLoader.
  ///
  /// \param[in] loader loader to write to
  /// \param[in] fname path to the file to read
  void exif_loader_write_file(
    ffi.Pointer<ExifLoader> loader,
    ffi.Pointer<ffi.Char> fname,
  ) {
    return _exif_loader_write_file(
      loader,
      fname,
    );
  }

  late final _exif_loader_write_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ExifLoader>,
              ffi.Pointer<ffi.Char>)>>('exif_loader_write_file');
  late final _exif_loader_write_file = _exif_loader_write_filePtr.asFunction<
      void Function(ffi.Pointer<ExifLoader>, ffi.Pointer<ffi.Char>)>();

  /// ! Load a buffer into the #ExifLoader from a memory buffer.
  /// The relevant data is copied in raw form into the #ExifLoader.
  ///
  /// \param[in] loader loader to write to
  /// \param[in] buf buffer to read from
  /// \param[in] sz size of the buffer
  /// \return 1 while EXIF data is read (or while there is still hope that
  /// there will be EXIF data later on), 0 otherwise.
  int exif_loader_write(
    ffi.Pointer<ExifLoader> loader,
    ffi.Pointer<ffi.UnsignedChar> buf,
    int sz,
  ) {
    return _exif_loader_write(
      loader,
      buf,
      sz,
    );
  }

  late final _exif_loader_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedChar Function(
              ffi.Pointer<ExifLoader>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedInt)>>('exif_loader_write');
  late final _exif_loader_write = _exif_loader_writePtr.asFunction<
      int Function(
          ffi.Pointer<ExifLoader>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// ! Free any data previously loaded and reset the #ExifLoader to its
  /// newly-initialized state.
  ///
  /// \param[in] loader the loader
  void exif_loader_reset(
    ffi.Pointer<ExifLoader> loader,
  ) {
    return _exif_loader_reset(
      loader,
    );
  }

  late final _exif_loader_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifLoader>)>>(
          'exif_loader_reset');
  late final _exif_loader_reset = _exif_loader_resetPtr
      .asFunction<void Function(ffi.Pointer<ExifLoader>)>();

  /// ! Create an #ExifData from the data in the loader. The loader must
  /// already contain data from a previous call to #exif_loader_write_file
  /// or #exif_loader_write.
  ///
  /// \note The #ExifData returned is created using its default options, which
  /// may take effect before the data is returned. If other options are desired,
  /// an #ExifData must be created explicitly and data extracted from the loader
  /// using #exif_loader_get_buf instead.
  ///
  /// \param[in] loader the loader
  /// \return allocated ExifData
  ///
  /// \see exif_loader_get_buf
  ffi.Pointer<ExifData> exif_loader_get_data(
    ffi.Pointer<ExifLoader> loader,
  ) {
    return _exif_loader_get_data(
      loader,
    );
  }

  late final _exif_loader_get_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ExifData> Function(
              ffi.Pointer<ExifLoader>)>>('exif_loader_get_data');
  late final _exif_loader_get_data = _exif_loader_get_dataPtr
      .asFunction<ffi.Pointer<ExifData> Function(ffi.Pointer<ExifLoader>)>();

  /// ! Return the raw data read by the loader.  The returned pointer is only
  /// guaranteed to be valid until the next call to a function modifying
  /// this #ExifLoader.  Either or both of buf and buf_size may be NULL on
  /// entry, in which case that value is not returned.
  ///
  /// \param[in] loader the loader
  /// \param[out] buf read-only pointer to the data read by the loader, or NULL
  /// in case of error
  /// \param[out] buf_size size of the data at buf, or 0 in case of error
  void exif_loader_get_buf(
    ffi.Pointer<ExifLoader> loader,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> buf,
    ffi.Pointer<ffi.UnsignedInt> buf_size,
  ) {
    return _exif_loader_get_buf(
      loader,
      buf,
      buf_size,
    );
  }

  late final _exif_loader_get_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ExifLoader>,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.UnsignedInt>)>>('exif_loader_get_buf');
  late final _exif_loader_get_buf = _exif_loader_get_bufPtr.asFunction<
      void Function(
          ffi.Pointer<ExifLoader>,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// ! Set the log message object used by this #ExifLoader.
  /// \param[in] loader the loader
  /// \param[in] log #ExifLog
  void exif_loader_log(
    ffi.Pointer<ExifLoader> loader,
    ffi.Pointer<ExifLog> log,
  ) {
    return _exif_loader_log(
      loader,
      log,
    );
  }

  late final _exif_loader_logPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ExifLoader>,
              ffi.Pointer<ExifLog>)>>('exif_loader_log');
  late final _exif_loader_log = _exif_loader_logPtr.asFunction<
      void Function(ffi.Pointer<ExifLoader>, ffi.Pointer<ExifLog>)>();

  ffi.Pointer<ffi.Char> mnote_canon_tag_get_name(
    int arg0,
  ) {
    return _mnote_canon_tag_get_name(
      arg0,
    );
  }

  late final _mnote_canon_tag_get_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'mnote_canon_tag_get_name');
  late final _mnote_canon_tag_get_name = _mnote_canon_tag_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<ffi.Char> mnote_canon_tag_get_name_sub(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _mnote_canon_tag_get_name_sub(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _mnote_canon_tag_get_name_subPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Int32, ffi.UnsignedInt,
              ffi.Int32)>>('mnote_canon_tag_get_name_sub');
  late final _mnote_canon_tag_get_name_sub = _mnote_canon_tag_get_name_subPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int, int, int)>();

  ffi.Pointer<ffi.Char> mnote_canon_tag_get_title(
    int arg0,
  ) {
    return _mnote_canon_tag_get_title(
      arg0,
    );
  }

  late final _mnote_canon_tag_get_titlePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'mnote_canon_tag_get_title');
  late final _mnote_canon_tag_get_title = _mnote_canon_tag_get_titlePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<ffi.Char> mnote_canon_tag_get_title_sub(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _mnote_canon_tag_get_title_sub(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _mnote_canon_tag_get_title_subPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Int32, ffi.UnsignedInt,
              ffi.Int32)>>('mnote_canon_tag_get_title_sub');
  late final _mnote_canon_tag_get_title_sub = _mnote_canon_tag_get_title_subPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int, int, int)>();

  ffi.Pointer<ffi.Char> mnote_canon_tag_get_description(
    int arg0,
  ) {
    return _mnote_canon_tag_get_description(
      arg0,
    );
  }

  late final _mnote_canon_tag_get_descriptionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'mnote_canon_tag_get_description');
  late final _mnote_canon_tag_get_description =
      _mnote_canon_tag_get_descriptionPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int mnote_canon_entry_count_values(
    ffi.Pointer<MnoteCanonEntry> arg0,
  ) {
    return _mnote_canon_entry_count_values(
      arg0,
    );
  }

  late final _mnote_canon_entry_count_valuesPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<MnoteCanonEntry>)>>('mnote_canon_entry_count_values');
  late final _mnote_canon_entry_count_values =
      _mnote_canon_entry_count_valuesPtr
          .asFunction<int Function(ffi.Pointer<MnoteCanonEntry>)>();

  ffi.Pointer<ffi.Char> mnote_canon_entry_get_value(
    ffi.Pointer<MnoteCanonEntry> arg0,
    int t,
    ffi.Pointer<ffi.Char> val,
    int maxlen,
  ) {
    return _mnote_canon_entry_get_value(
      arg0,
      t,
      val,
      maxlen,
    );
  }

  late final _mnote_canon_entry_get_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MnoteCanonEntry>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('mnote_canon_entry_get_value');
  late final _mnote_canon_entry_get_value =
      _mnote_canon_entry_get_valuePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MnoteCanonEntry>, int, ffi.Pointer<ffi.Char>, int)>();

  /// ! Detect if MakerNote is recognized as one handled by the Canon module.
  ///
  /// \param[in] ed image #ExifData to identify as as a Canon type
  /// \param[in] e #ExifEntry for EXIF_TAG_MAKER_NOTE, from within ed but
  /// duplicated here for convenience
  /// \return 0 if not recognized, nonzero if recognized. The specific nonzero
  /// value returned may identify a subtype unique within this module.
  int exif_mnote_data_canon_identify(
    ffi.Pointer<ExifData> ed,
    ffi.Pointer<ExifEntry> e,
  ) {
    return _exif_mnote_data_canon_identify(
      ed,
      e,
    );
  }

  late final _exif_mnote_data_canon_identifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ExifData>,
              ffi.Pointer<ExifEntry>)>>('exif_mnote_data_canon_identify');
  late final _exif_mnote_data_canon_identify =
      _exif_mnote_data_canon_identifyPtr.asFunction<
          int Function(ffi.Pointer<ExifData>, ffi.Pointer<ExifEntry>)>();

  ffi.Pointer<ExifMnoteData> exif_mnote_data_canon_new(
    ffi.Pointer<ExifMem> mem,
    int o,
  ) {
    return _exif_mnote_data_canon_new(
      mem,
      o,
    );
  }

  late final _exif_mnote_data_canon_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ExifMnoteData> Function(
              ffi.Pointer<ExifMem>, ffi.Int32)>>('exif_mnote_data_canon_new');
  late final _exif_mnote_data_canon_new =
      _exif_mnote_data_canon_newPtr.asFunction<
          ffi.Pointer<ExifMnoteData> Function(ffi.Pointer<ExifMem>, int)>();

  ffi.Pointer<ffi.Char> mnote_pentax_tag_get_name(
    int tag,
  ) {
    return _mnote_pentax_tag_get_name(
      tag,
    );
  }

  late final _mnote_pentax_tag_get_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'mnote_pentax_tag_get_name');
  late final _mnote_pentax_tag_get_name = _mnote_pentax_tag_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<ffi.Char> mnote_pentax_tag_get_title(
    int tag,
  ) {
    return _mnote_pentax_tag_get_title(
      tag,
    );
  }

  late final _mnote_pentax_tag_get_titlePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'mnote_pentax_tag_get_title');
  late final _mnote_pentax_tag_get_title = _mnote_pentax_tag_get_titlePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<ffi.Char> mnote_pentax_tag_get_description(
    int tag,
  ) {
    return _mnote_pentax_tag_get_description(
      tag,
    );
  }

  late final _mnote_pentax_tag_get_descriptionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'mnote_pentax_tag_get_description');
  late final _mnote_pentax_tag_get_description =
      _mnote_pentax_tag_get_descriptionPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<ffi.Char> mnote_pentax_entry_get_value(
    ffi.Pointer<MnotePentaxEntry> entry,
    ffi.Pointer<ffi.Char> val,
    int maxlen,
  ) {
    return _mnote_pentax_entry_get_value(
      entry,
      val,
      maxlen,
    );
  }

  late final _mnote_pentax_entry_get_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MnotePentaxEntry>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('mnote_pentax_entry_get_value');
  late final _mnote_pentax_entry_get_value =
      _mnote_pentax_entry_get_valuePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MnotePentaxEntry>, ffi.Pointer<ffi.Char>, int)>();

  /// ! Detect if MakerNote is recognized as one handled by the Pentax module.
  ///
  /// \param[in] ed image #ExifData to identify as as a Pentax type
  /// \param[in] e #ExifEntry for EXIF_TAG_MAKER_NOTE, from within ed but
  /// duplicated here for convenience
  /// \return 0 if not recognized, nonzero if recognized. The specific nonzero
  /// value returned may identify a subtype unique within this module.
  int exif_mnote_data_pentax_identify(
    ffi.Pointer<ExifData> ed,
    ffi.Pointer<ExifEntry> e,
  ) {
    return _exif_mnote_data_pentax_identify(
      ed,
      e,
    );
  }

  late final _exif_mnote_data_pentax_identifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ExifData>,
              ffi.Pointer<ExifEntry>)>>('exif_mnote_data_pentax_identify');
  late final _exif_mnote_data_pentax_identify =
      _exif_mnote_data_pentax_identifyPtr.asFunction<
          int Function(ffi.Pointer<ExifData>, ffi.Pointer<ExifEntry>)>();

  ffi.Pointer<ExifMnoteData> exif_mnote_data_pentax_new(
    ffi.Pointer<ExifMem> arg0,
  ) {
    return _exif_mnote_data_pentax_new(
      arg0,
    );
  }

  late final _exif_mnote_data_pentax_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ExifMnoteData> Function(
              ffi.Pointer<ExifMem>)>>('exif_mnote_data_pentax_new');
  late final _exif_mnote_data_pentax_new = _exif_mnote_data_pentax_newPtr
      .asFunction<ffi.Pointer<ExifMnoteData> Function(ffi.Pointer<ExifMem>)>();
}

abstract class _MnoteAppleTag {
  static const int MNOTE_APPLE_TAG_RUNTIME = 3;
  static const int MNOTE_APPLE_TAG_ACCELERATION_VECTOR = 9;
  static const int MNOTE_APPLE_TAG_HDR = 10;
  static const int MNOTE_APPLE_TAG_BURST_UUID = 11;
  static const int MNOTE_APPLE_TAG_MEDIA_GROUP_UUID = 17;
  static const int MNOTE_APPLE_TAG_IMAGE_UNIQUE_ID = 21;
}

/// ! Which byte order to use
abstract class ExifByteOrder {
  /// ! Big-endian byte order
  static const int EXIF_BYTE_ORDER_MOTOROLA = 0;

  /// ! Little-endian byte order
  static const int EXIF_BYTE_ORDER_INTEL = 1;
}

/// ! Represents the type of image data to which the EXIF data applies.
/// The EXIF tags have different constraints depending on the type of
/// image data.
abstract class ExifDataType {
  static const int EXIF_DATA_TYPE_UNCOMPRESSED_CHUNKY = 0;
  static const int EXIF_DATA_TYPE_UNCOMPRESSED_PLANAR = 1;
  static const int EXIF_DATA_TYPE_UNCOMPRESSED_YCC = 2;
  static const int EXIF_DATA_TYPE_COMPRESSED = 3;
  static const int EXIF_DATA_TYPE_COUNT = 4;
  static const int EXIF_DATA_TYPE_UNKNOWN = 4;
}

/// ! Possible EXIF Image File Directories
abstract class ExifIfd {
  /// !<
  static const int EXIF_IFD_0 = 0;

  /// !<
  static const int EXIF_IFD_1 = 1;

  /// !<
  static const int EXIF_IFD_EXIF = 2;

  /// !<
  static const int EXIF_IFD_GPS = 3;

  /// !<
  static const int EXIF_IFD_INTEROPERABILITY = 4;

  /// !< Not a real value, just (max_value + 1).
  static const int EXIF_IFD_COUNT = 5;
}

/// ! EXIF tag data formats
abstract class ExifFormat {
  static const int EXIF_FORMAT_BYTE = 1;
  static const int EXIF_FORMAT_ASCII = 2;
  static const int EXIF_FORMAT_SHORT = 3;
  static const int EXIF_FORMAT_LONG = 4;
  static const int EXIF_FORMAT_RATIONAL = 5;
  static const int EXIF_FORMAT_SBYTE = 6;
  static const int EXIF_FORMAT_UNDEFINED = 7;
  static const int EXIF_FORMAT_SSHORT = 8;
  static const int EXIF_FORMAT_SLONG = 9;
  static const int EXIF_FORMAT_SRATIONAL = 10;
  static const int EXIF_FORMAT_FLOAT = 11;
  static const int EXIF_FORMAT_DOUBLE = 12;
}

/// ! EXIF Unsigned Short data type
typedef ExifShort = ffi.Uint16;

/// ! EXIF Signed Short data type
typedef ExifSShort = ffi.Int16;

/// ! EXIF Unsigned Long data type
typedef ExifLong = ffi.Uint32;

/// ! EXIF Signed Long data type
typedef ExifSLong = ffi.Int32;

/// ! EXIF Unsigned Rational data type
final class ExifRational extends ffi.Struct {
  @ExifLong()
  external int numerator;

  @ExifLong()
  external int denominator;
}

/// ! EXIF Signed Rational data type
final class ExifSRational extends ffi.Struct {
  @ExifSLong()
  external int numerator;

  @ExifSLong()
  external int denominator;
}

final class _ExifMem extends ffi.Opaque {}

/// ! ExifMem define a memory allocator
typedef ExifMem = _ExifMem;

/// ! Should work like calloc()
///
/// \param[in] s the size of the block to allocate.
/// \return the allocated memory and initialized.
typedef ExifMemAllocFunc = ffi
    .Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ExifLong s)>>;

/// ! Should work like realloc()
///
/// \param[in] p the pointer to reallocate
/// \param[in] s the size of the reallocated block
/// \return allocated memory
typedef ExifMemReallocFunc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void> p, ExifLong s)>>;

/// ! Free method for ExifMem
///
/// \param[in] p the pointer to free
/// \return the freed pointer
typedef ExifMemFreeFunc = ffi
    .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> p)>>;

final class _ExifLog extends ffi.Opaque {}

/// ! State maintained by the logging interface
typedef ExifLog = _ExifLog;

abstract class ExifLogCode {
  static const int EXIF_LOG_CODE_NONE = 0;
  static const int EXIF_LOG_CODE_DEBUG = 1;
  static const int EXIF_LOG_CODE_NO_MEMORY = 2;
  static const int EXIF_LOG_CODE_CORRUPT_DATA = 3;
}

/// ! Log callback function prototype.
typedef ExifLogFunc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ExifLog>,
            ffi.Int32,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            va_list,
            ffi.Pointer<ffi.Void>)>>;
typedef va_list = ffi.Pointer<ffi.Char>;

/// ! EXIF tags
abstract class ExifTag {
  static const int EXIF_TAG_INTEROPERABILITY_INDEX = 1;
  static const int EXIF_TAG_INTEROPERABILITY_VERSION = 2;
  static const int EXIF_TAG_NEW_SUBFILE_TYPE = 254;
  static const int EXIF_TAG_IMAGE_WIDTH = 256;
  static const int EXIF_TAG_IMAGE_LENGTH = 257;
  static const int EXIF_TAG_BITS_PER_SAMPLE = 258;
  static const int EXIF_TAG_COMPRESSION = 259;
  static const int EXIF_TAG_PHOTOMETRIC_INTERPRETATION = 262;
  static const int EXIF_TAG_FILL_ORDER = 266;
  static const int EXIF_TAG_DOCUMENT_NAME = 269;
  static const int EXIF_TAG_IMAGE_DESCRIPTION = 270;
  static const int EXIF_TAG_MAKE = 271;
  static const int EXIF_TAG_MODEL = 272;
  static const int EXIF_TAG_STRIP_OFFSETS = 273;
  static const int EXIF_TAG_ORIENTATION = 274;
  static const int EXIF_TAG_SAMPLES_PER_PIXEL = 277;
  static const int EXIF_TAG_ROWS_PER_STRIP = 278;
  static const int EXIF_TAG_STRIP_BYTE_COUNTS = 279;
  static const int EXIF_TAG_X_RESOLUTION = 282;
  static const int EXIF_TAG_Y_RESOLUTION = 283;
  static const int EXIF_TAG_PLANAR_CONFIGURATION = 284;
  static const int EXIF_TAG_RESOLUTION_UNIT = 296;
  static const int EXIF_TAG_TRANSFER_FUNCTION = 301;
  static const int EXIF_TAG_SOFTWARE = 305;
  static const int EXIF_TAG_DATE_TIME = 306;
  static const int EXIF_TAG_ARTIST = 315;
  static const int EXIF_TAG_WHITE_POINT = 318;
  static const int EXIF_TAG_PRIMARY_CHROMATICITIES = 319;
  static const int EXIF_TAG_SUB_IFDS = 330;
  static const int EXIF_TAG_TRANSFER_RANGE = 342;
  static const int EXIF_TAG_JPEG_PROC = 512;
  static const int EXIF_TAG_JPEG_INTERCHANGE_FORMAT = 513;
  static const int EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH = 514;
  static const int EXIF_TAG_YCBCR_COEFFICIENTS = 529;
  static const int EXIF_TAG_YCBCR_SUB_SAMPLING = 530;
  static const int EXIF_TAG_YCBCR_POSITIONING = 531;
  static const int EXIF_TAG_REFERENCE_BLACK_WHITE = 532;
  static const int EXIF_TAG_XML_PACKET = 700;
  static const int EXIF_TAG_RELATED_IMAGE_FILE_FORMAT = 4096;
  static const int EXIF_TAG_RELATED_IMAGE_WIDTH = 4097;
  static const int EXIF_TAG_RELATED_IMAGE_LENGTH = 4098;
  static const int EXIF_TAG_IMAGE_DEPTH = 32997;
  static const int EXIF_TAG_CFA_REPEAT_PATTERN_DIM = 33421;
  static const int EXIF_TAG_CFA_PATTERN = 33422;
  static const int EXIF_TAG_BATTERY_LEVEL = 33423;
  static const int EXIF_TAG_COPYRIGHT = 33432;
  static const int EXIF_TAG_EXPOSURE_TIME = 33434;
  static const int EXIF_TAG_FNUMBER = 33437;
  static const int EXIF_TAG_IPTC_NAA = 33723;
  static const int EXIF_TAG_IMAGE_RESOURCES = 34377;
  static const int EXIF_TAG_EXIF_IFD_POINTER = 34665;
  static const int EXIF_TAG_INTER_COLOR_PROFILE = 34675;
  static const int EXIF_TAG_EXPOSURE_PROGRAM = 34850;
  static const int EXIF_TAG_SPECTRAL_SENSITIVITY = 34852;
  static const int EXIF_TAG_GPS_INFO_IFD_POINTER = 34853;
  static const int EXIF_TAG_ISO_SPEED_RATINGS = 34855;
  static const int EXIF_TAG_OECF = 34856;
  static const int EXIF_TAG_TIME_ZONE_OFFSET = 34858;
  static const int EXIF_TAG_SENSITIVITY_TYPE = 34864;
  static const int EXIF_TAG_STANDARD_OUTPUT_SENSITIVITY = 34865;
  static const int EXIF_TAG_RECOMMENDED_EXPOSURE_INDEX = 34866;
  static const int EXIF_TAG_ISO_SPEED = 34867;
  static const int EXIF_TAG_ISO_SPEEDLatitudeYYY = 34868;
  static const int EXIF_TAG_ISO_SPEEDLatitudeZZZ = 34869;
  static const int EXIF_TAG_EXIF_VERSION = 36864;
  static const int EXIF_TAG_DATE_TIME_ORIGINAL = 36867;
  static const int EXIF_TAG_DATE_TIME_DIGITIZED = 36868;
  static const int EXIF_TAG_OFFSET_TIME = 36880;
  static const int EXIF_TAG_OFFSET_TIME_ORIGINAL = 36881;
  static const int EXIF_TAG_OFFSET_TIME_DIGITIZED = 36882;
  static const int EXIF_TAG_COMPONENTS_CONFIGURATION = 37121;
  static const int EXIF_TAG_COMPRESSED_BITS_PER_PIXEL = 37122;
  static const int EXIF_TAG_SHUTTER_SPEED_VALUE = 37377;
  static const int EXIF_TAG_APERTURE_VALUE = 37378;
  static const int EXIF_TAG_BRIGHTNESS_VALUE = 37379;
  static const int EXIF_TAG_EXPOSURE_BIAS_VALUE = 37380;
  static const int EXIF_TAG_MAX_APERTURE_VALUE = 37381;
  static const int EXIF_TAG_SUBJECT_DISTANCE = 37382;
  static const int EXIF_TAG_METERING_MODE = 37383;
  static const int EXIF_TAG_LIGHT_SOURCE = 37384;
  static const int EXIF_TAG_FLASH = 37385;
  static const int EXIF_TAG_FOCAL_LENGTH = 37386;
  static const int EXIF_TAG_SUBJECT_AREA = 37396;
  static const int EXIF_TAG_TIFF_EP_STANDARD_ID = 37398;
  static const int EXIF_TAG_MAKER_NOTE = 37500;
  static const int EXIF_TAG_USER_COMMENT = 37510;
  static const int EXIF_TAG_SUB_SEC_TIME = 37520;
  static const int EXIF_TAG_SUB_SEC_TIME_ORIGINAL = 37521;
  static const int EXIF_TAG_SUB_SEC_TIME_DIGITIZED = 37522;
  static const int EXIF_TAG_XP_TITLE = 40091;
  static const int EXIF_TAG_XP_COMMENT = 40092;
  static const int EXIF_TAG_XP_AUTHOR = 40093;
  static const int EXIF_TAG_XP_KEYWORDS = 40094;
  static const int EXIF_TAG_XP_SUBJECT = 40095;
  static const int EXIF_TAG_FLASH_PIX_VERSION = 40960;
  static const int EXIF_TAG_COLOR_SPACE = 40961;
  static const int EXIF_TAG_PIXEL_X_DIMENSION = 40962;
  static const int EXIF_TAG_PIXEL_Y_DIMENSION = 40963;
  static const int EXIF_TAG_RELATED_SOUND_FILE = 40964;
  static const int EXIF_TAG_INTEROPERABILITY_IFD_POINTER = 40965;
  static const int EXIF_TAG_FLASH_ENERGY = 41483;
  static const int EXIF_TAG_SPATIAL_FREQUENCY_RESPONSE = 41484;
  static const int EXIF_TAG_FOCAL_PLANE_X_RESOLUTION = 41486;
  static const int EXIF_TAG_FOCAL_PLANE_Y_RESOLUTION = 41487;
  static const int EXIF_TAG_FOCAL_PLANE_RESOLUTION_UNIT = 41488;
  static const int EXIF_TAG_SUBJECT_LOCATION = 41492;
  static const int EXIF_TAG_EXPOSURE_INDEX = 41493;
  static const int EXIF_TAG_SENSING_METHOD = 41495;
  static const int EXIF_TAG_FILE_SOURCE = 41728;
  static const int EXIF_TAG_SCENE_TYPE = 41729;
  static const int EXIF_TAG_NEW_CFA_PATTERN = 41730;
  static const int EXIF_TAG_CUSTOM_RENDERED = 41985;
  static const int EXIF_TAG_EXPOSURE_MODE = 41986;
  static const int EXIF_TAG_WHITE_BALANCE = 41987;
  static const int EXIF_TAG_DIGITAL_ZOOM_RATIO = 41988;
  static const int EXIF_TAG_FOCAL_LENGTH_IN_35MM_FILM = 41989;
  static const int EXIF_TAG_SCENE_CAPTURE_TYPE = 41990;
  static const int EXIF_TAG_GAIN_CONTROL = 41991;
  static const int EXIF_TAG_CONTRAST = 41992;
  static const int EXIF_TAG_SATURATION = 41993;
  static const int EXIF_TAG_SHARPNESS = 41994;
  static const int EXIF_TAG_DEVICE_SETTING_DESCRIPTION = 41995;
  static const int EXIF_TAG_SUBJECT_DISTANCE_RANGE = 41996;
  static const int EXIF_TAG_IMAGE_UNIQUE_ID = 42016;
  static const int EXIF_TAG_CAMERA_OWNER_NAME = 42032;
  static const int EXIF_TAG_BODY_SERIAL_NUMBER = 42033;
  static const int EXIF_TAG_LENS_SPECIFICATION = 42034;
  static const int EXIF_TAG_LENS_MAKE = 42035;
  static const int EXIF_TAG_LENS_MODEL = 42036;
  static const int EXIF_TAG_LENS_SERIAL_NUMBER = 42037;
  static const int EXIF_TAG_COMPOSITE_IMAGE = 42080;
  static const int EXIF_TAG_SOURCE_IMAGE_NUMBER_OF_COMPOSITE_IMAGE = 42081;
  static const int EXIF_TAG_SOURCE_EXPOSURE_TIMES_OF_COMPOSITE_IMAGE = 42082;
  static const int EXIF_TAG_GAMMA = 42240;
  static const int EXIF_TAG_PRINT_IMAGE_MATCHING = 50341;
  static const int EXIF_TAG_PADDING = 59932;
}

/// ! What level of support a tag enjoys in the EXIF standard
abstract class ExifSupportLevel {
  /// ! The meaning of this tag is unknown
  static const int EXIF_SUPPORT_LEVEL_UNKNOWN = 0;

  /// ! This tag is not allowed in the given IFD
  static const int EXIF_SUPPORT_LEVEL_NOT_RECORDED = 1;

  /// ! This tag is mandatory in the given IFD
  static const int EXIF_SUPPORT_LEVEL_MANDATORY = 2;

  /// ! This tag is optional in the given IFD
  static const int EXIF_SUPPORT_LEVEL_OPTIONAL = 3;
}

/// ! Represents the entire EXIF data found in an image
final class _ExifData extends ffi.Struct {
  /// ! Data for each IFD
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Pointer<ExifContent>> ifd;

  /// ! Pointer to thumbnail image, or NULL if not available
  external ffi.Pointer<ffi.UnsignedChar> data;

  /// ! Number of bytes in thumbnail image at \c data
  @ffi.UnsignedInt()
  external int size;

  external ffi.Pointer<ExifDataPrivate> priv;
}

/// ! Holds all EXIF tags in a single IFD
typedef ExifContent = _ExifContent;

final class _ExifContent extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<ExifEntry>> entries;

  @ffi.UnsignedInt()
  external int count;

  /// ! Data containing this content
  external ffi.Pointer<ExifData> parent;

  external ffi.Pointer<ExifContentPrivate> priv;
}

/// ! Data found in one EXIF tag.
/// The #exif_entry_get_value function can provide access to the
/// formatted contents, or the struct members can be used directly to
/// access the raw contents.
typedef ExifEntry = _ExifEntry;

/// ! Data found in one EXIF tag
final class _ExifEntry extends ffi.Struct {
  /// ! EXIF tag for this entry
  @ffi.Int32()
  external int tag;

  /// ! Type of data in this entry
  @ffi.Int32()
  external int format;

  /// ! Number of elements in the array, if this is an array entry.
  /// Contains 1 for non-array data types.
  @ffi.UnsignedLong()
  external int components;

  /// ! Pointer to the raw EXIF data for this entry. It is allocated
  /// by #exif_entry_initialize and is NULL beforehand. Data contained
  /// here may be manipulated using the functions in exif-utils.h
  external ffi.Pointer<ffi.UnsignedChar> data;

  /// ! Number of bytes in the buffer at \c data. This must be no less
  /// than exif_format_get_size(format)*components
  @ffi.UnsignedInt()
  external int size;

  /// ! #ExifContent containing this entry.
  /// \see exif_entry_get_ifd
  external ffi.Pointer<ExifContent1> parent;

  /// ! Internal data to be used by libexif itself
  external ffi.Pointer<ExifEntryPrivate> priv;
}

/// ! Holds all EXIF tags in a single IFD
typedef ExifContent1 = _ExifContent;
typedef ExifEntryPrivate = _ExifEntryPrivate;

final class _ExifEntryPrivate extends ffi.Opaque {}

/// ! Represents the entire EXIF data found in an image
typedef ExifData = _ExifData;
typedef ExifContentPrivate = _ExifContentPrivate;

final class _ExifContentPrivate extends ffi.Opaque {}

typedef ExifDataPrivate = _ExifDataPrivate;

final class _ExifDataPrivate extends ffi.Opaque {}

typedef ExifContentForeachEntryFunc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ExifEntry>, ffi.Pointer<ffi.Void>)>>;

/// ! \internal
final class _ExifMnoteData extends ffi.Struct {
  external ffi.Pointer<ExifMnoteDataPriv> priv;

  external ExifMnoteDataMethods methods;

  external ffi.Pointer<ExifLog> log;

  external ffi.Pointer<ExifMem> mem;
}

/// ! \internal
typedef ExifMnoteDataPriv = _ExifMnoteDataPriv;

final class _ExifMnoteDataPriv extends ffi.Opaque {}

/// ! \internal
typedef ExifMnoteDataMethods = _ExifMnoteDataMethods;

/// ! \internal
final class _ExifMnoteDataMethods extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ExifMnoteData>)>> free;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ExifMnoteData>,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.UnsignedInt>)>> save;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ExifMnoteData>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>> load;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ExifMnoteData>, ffi.UnsignedInt)>>
      set_offset;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ExifMnoteData>, ffi.Int32)>>
      set_byte_order;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<ExifMnoteData>)>>
      count;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<ExifMnoteData>, ffi.UnsignedInt)>> get_id;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ExifMnoteData>, ffi.UnsignedInt)>> get_name;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ExifMnoteData>, ffi.UnsignedInt)>> get_title;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ExifMnoteData>, ffi.UnsignedInt)>> get_description;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ExifMnoteData>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>> get_value;
}

/// ! Data found in the MakerNote tag
typedef ExifMnoteData = _ExifMnoteData;
typedef ExifDataForeachContentFunc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ExifContent>, ffi.Pointer<ffi.Void>)>>;

/// ! Options to configure the behaviour of #ExifData
abstract class ExifDataOption {
  /// ! Act as though unknown tags are not present
  static const int EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS = 1;

  /// ! Fix the EXIF tags to follow the spec
  static const int EXIF_DATA_OPTION_FOLLOW_SPECIFICATION = 2;

  /// ! Leave the MakerNote alone, which could cause it to be corrupted
  static const int EXIF_DATA_OPTION_DONT_CHANGE_MAKER_NOTE = 4;
}

final class _MnoteAppleEntry extends ffi.Struct {
  @ffi.Int32()
  external int tag;

  @ffi.Int32()
  external int format;

  @ffi.UnsignedLong()
  external int components;

  external ffi.Pointer<ffi.UnsignedChar> data;

  @ffi.UnsignedInt()
  external int size;

  @ffi.Int32()
  external int order;
}

typedef MnoteAppleEntry = _MnoteAppleEntry;

final class _ExifMnoteDataApple extends ffi.Struct {
  external ExifMnoteData parent;

  @ffi.Int32()
  external int order;

  @ffi.UnsignedInt()
  external int offset;

  external ffi.Pointer<MnoteAppleEntry> entries;

  @ffi.UnsignedInt()
  external int count;
}

abstract class _MnoteOlympusTag {
  static const int MNOTE_NIKON_TAG_FIRMWARE = 1;
  static const int MNOTE_NIKON_TAG_ISO = 2;
  static const int MNOTE_NIKON_TAG_COLORMODE1 = 3;
  static const int MNOTE_NIKON_TAG_QUALITY = 4;
  static const int MNOTE_NIKON_TAG_WHITEBALANCE = 5;
  static const int MNOTE_NIKON_TAG_SHARPENING = 6;
  static const int MNOTE_NIKON_TAG_FOCUSMODE = 7;
  static const int MNOTE_NIKON_TAG_FLASHSETTING = 8;
  static const int MNOTE_NIKON_TAG_FLASHMODE = 9;
  static const int MNOTE_NIKON_TAG_WHITEBALANCEFINE = 11;
  static const int MNOTE_NIKON_TAG_WHITEBALANCERB = 12;
  static const int MNOTE_NIKON_TAG_PROGRAMSHIFT = 13;
  static const int MNOTE_NIKON_TAG_EXPOSUREDIFF = 14;
  static const int MNOTE_NIKON_TAG_ISOSELECTION = 15;
  static const int MNOTE_NIKON_TAG_PREVIEWIMAGE_IFD_POINTER = 17;
  static const int MNOTE_NIKON_TAG_FLASHEXPCOMPENSATION = 18;
  static const int MNOTE_NIKON_TAG_ISO2 = 19;
  static const int MNOTE_NIKON_TAG_IMAGEBOUNDARY = 22;
  static const int MNOTE_NIKON_TAG_EXTERNALFLASHEXPCOMPENSATION = 23;
  static const int MNOTE_NIKON_TAG_FLASHEXPOSUREBRACKETVAL = 24;
  static const int MNOTE_NIKON_TAG_EXPOSUREBRACKETVAL = 25;
  static const int MNOTE_NIKON_TAG_CROPHISPEED = 27;
  static const int MNOTE_NIKON_TAG_EXPOSURETUNING = 28;
  static const int MNOTE_NIKON_TAG_SERIALNUMBER = 29;
  static const int MNOTE_NIKON_TAG_COLORSPACE = 30;
  static const int MNOTE_NIKON_TAG_VRINFO = 31;
  static const int MNOTE_NIKON_TAG_IMAGEAUTHENTICATION = 32;
  static const int MNOTE_NIKON_TAG_FACEDETECT = 33;
  static const int MNOTE_NIKON_TAG_ACTIVEDLIGHTING = 34;
  static const int MNOTE_NIKON_TAG_PICTURECONTROLDATA = 35;
  static const int MNOTE_NIKON_TAG_WORLDTIME = 36;
  static const int MNOTE_NIKON_TAG_ISOINFO = 37;
  static const int MNOTE_NIKON_TAG_VIGNETTECONTROL = 42;
  static const int MNOTE_NIKON_TAG_DISTORTINFO = 43;
  static const int MNOTE_NIKON_TAG_SHUTTERMODE = 52;
  static const int MNOTE_NIKON_TAG_HDRINFO = 53;
  static const int MNOTE_NIKON_TAG_MECHANICALSHUTTERCOUNT = 55;
  static const int MNOTE_NIKON_TAG_LOCATIONINFO = 57;
  static const int MNOTE_NIKON_TAG_BLACKLEVEL = 61;
  static const int MNOTE_NIKON_TAG_IMAGESIZERAW = 62;
  static const int MNOTE_NIKON_TAG_CROPAREA = 69;
  static const int MNOTE_NIKON_TAG_NIKONSETTINGS = 78;
  static const int MNOTE_NIKON_TAG_COLORTEMPERATUREAUTO = 79;
  static const int MNOTE_NIKON_TAG_IMAGEADJUSTMENT = 128;
  static const int MNOTE_NIKON_TAG_TONECOMPENSATION = 129;
  static const int MNOTE_NIKON_TAG_ADAPTER = 130;
  static const int MNOTE_NIKON_TAG_LENSTYPE = 131;
  static const int MNOTE_NIKON_TAG_LENS = 132;
  static const int MNOTE_NIKON_TAG_MANUALFOCUSDISTANCE = 133;
  static const int MNOTE_NIKON_TAG_DIGITALZOOM = 134;
  static const int MNOTE_NIKON_TAG_FLASHUSED = 135;
  static const int MNOTE_NIKON_TAG_AFFOCUSPOSITION = 136;
  static const int MNOTE_NIKON_TAG_BRACKETING = 137;
  static const int MNOTE_NIKON_TAG_UNKNOWN_0X008A = 138;
  static const int MNOTE_NIKON_TAG_LENS_FSTOPS = 139;
  static const int MNOTE_NIKON_TAG_CURVE = 140;
  static const int MNOTE_NIKON_TAG_COLORMODE = 141;
  static const int MNOTE_NIKON_TAG_LIGHTTYPE = 144;
  static const int MNOTE_NIKON_TAG_SHOTINFO = 145;
  static const int MNOTE_NIKON_TAG_HUE = 146;
  static const int MNOTE_NIKON_TAG_SATURATION = 148;
  static const int MNOTE_NIKON_TAG_NOISEREDUCTION = 149;
  static const int MNOTE_NIKON_TAG_COLORBALANCE = 151;
  static const int MNOTE_NIKON_TAG_LENSDATA = 152;
  static const int MNOTE_NIKON_TAG_SENSORPIXELSIZE = 154;
  static const int MNOTE_NIKON_TAG_UNKNOWN_0X009B = 155;
  static const int MNOTE_NIKON_TAG_RETOUCHHISTORY = 158;
  static const int MNOTE_NIKON_TAG_SERIALNUMBER2 = 160;
  static const int MNOTE_NIKON_TAG_IMAGE_DATASIZE = 162;
  static const int MNOTE_NIKON_TAG_UNKNOWN_0X00A3 = 163;
  static const int MNOTE_NIKON_TAG_TOTALPICTURES = 167;
  static const int MNOTE_NIKON_TAG_FLASHINFO = 168;
  static const int MNOTE_NIKON_TAG_OPTIMIZATION = 169;
  static const int MNOTE_NIKON_TAG_SATURATION2 = 170;
  static const int MNOTE_NIKON_TAG_VARIPROGRAM = 171;
  static const int MNOTE_NIKON_TAG_MULTIEXPOSURE = 176;
  static const int MNOTE_NIKON_TAG_HIGHISONR = 177;
  static const int MNOTE_NIKON_TAG_TONINGEFFECT = 179;
  static const int MNOTE_NIKON_TAG_POWERUPTIME = 182;
  static const int MNOTE_NIKON_TAG_AFINFO2 = 183;
  static const int MNOTE_NIKON_TAG_FILEINFO = 184;
  static const int MNOTE_NIKON_TAG_RETOUCHINFO = 187;
  static const int MNOTE_NIKON_TAG_CAPTUREEDITORDATA = 3585;
  static const int MNOTE_NIKON_TAG_CAPTUREEDITORVER = 3593;
  static const int MNOTE_NIKON_TAG_UNKNOWN_0X0E0E = 3598;
  static const int MNOTE_NIKON_TAG_UNKNOWN_0X0E10 = 3600;
  static const int MNOTE_NIKON1_TAG_BASE = 32768;
  static const int MNOTE_NIKON1_TAG_UNKNOWN_0X0002 = 32770;
  static const int MNOTE_NIKON1_TAG_QUALITY = 32771;
  static const int MNOTE_NIKON1_TAG_COLORMODE = 32772;
  static const int MNOTE_NIKON1_TAG_IMAGEADJUSTMENT = 32773;
  static const int MNOTE_NIKON1_TAG_CCDSENSITIVITY = 32774;
  static const int MNOTE_NIKON1_TAG_WHITEBALANCE = 32775;
  static const int MNOTE_NIKON1_TAG_FOCUS = 32776;
  static const int MNOTE_NIKON1_TAG_UNKNOWN_0X0009 = 32777;
  static const int MNOTE_NIKON1_TAG_DIGITALZOOM = 32778;
  static const int MNOTE_NIKON1_TAG_CONVERTER = 32779;
  static const int MNOTE_OLYMPUS_TAG_THUMBNAILIMAGE = 256;
  static const int MNOTE_OLYMPUS_TAG_MODE = 512;
  static const int MNOTE_OLYMPUS_TAG_QUALITY = 513;
  static const int MNOTE_OLYMPUS_TAG_MACRO = 514;
  static const int MNOTE_OLYMPUS_TAG_BWMODE = 515;
  static const int MNOTE_OLYMPUS_TAG_DIGIZOOM = 516;
  static const int MNOTE_OLYMPUS_TAG_FOCALPLANEDIAGONAL = 517;
  static const int MNOTE_OLYMPUS_TAG_LENSDISTORTION = 518;
  static const int MNOTE_OLYMPUS_TAG_VERSION = 519;
  static const int MNOTE_OLYMPUS_TAG_INFO = 520;
  static const int MNOTE_OLYMPUS_TAG_ID = 521;
  static const int MNOTE_OLYMPUS_TAG_PRECAPTUREFRAMES = 768;
  static const int MNOTE_OLYMPUS_TAG_WHITEBOARD = 769;
  static const int MNOTE_OLYMPUS_TAG_ONETOUCHWB = 770;
  static const int MNOTE_OLYMPUS_TAG_WHITEBALANCEBRACKET = 771;
  static const int MNOTE_OLYMPUS_TAG_WHITEBALANCEBIAS = 772;
  static const int MNOTE_OLYMPUS_TAG_DATADUMP = 3840;
  static const int MNOTE_OLYMPUS_TAG_UNKNOWN_4 = 3844;
  static const int MNOTE_OLYMPUS_TAG_SHUTTERSPEED = 4096;
  static const int MNOTE_OLYMPUS_TAG_ISOVALUE = 4097;
  static const int MNOTE_OLYMPUS_TAG_APERTUREVALUE = 4098;
  static const int MNOTE_OLYMPUS_TAG_BRIGHTNESSVALUE = 4099;
  static const int MNOTE_OLYMPUS_TAG_FLASHMODE = 4100;
  static const int MNOTE_OLYMPUS_TAG_FLASHDEVICE = 4101;
  static const int MNOTE_OLYMPUS_TAG_EXPOSURECOMP = 4102;
  static const int MNOTE_OLYMPUS_TAG_SENSORTEMPERATURE = 4103;
  static const int MNOTE_OLYMPUS_TAG_LENSTEMPERATURE = 4104;
  static const int MNOTE_OLYMPUS_TAG_LIGHTCONDITION = 4105;
  static const int MNOTE_OLYMPUS_TAG_FOCUSRANGE = 4106;
  static const int MNOTE_OLYMPUS_TAG_MANFOCUS = 4107;
  static const int MNOTE_OLYMPUS_TAG_FOCUSDIST = 4108;
  static const int MNOTE_OLYMPUS_TAG_ZOOMSTEPCOUNT = 4109;
  static const int MNOTE_OLYMPUS_TAG_FOCUSSTEPCOUNT = 4110;
  static const int MNOTE_OLYMPUS_TAG_SHARPNESS = 4111;
  static const int MNOTE_OLYMPUS_TAG_FLASHCHARGELEVEL = 4112;
  static const int MNOTE_OLYMPUS_TAG_COLORMATRIX = 4113;
  static const int MNOTE_OLYMPUS_TAG_BLACKLEVEL = 4114;
  static const int MNOTE_OLYMPUS_TAG_WBALANCE = 4117;
  static const int MNOTE_OLYMPUS_TAG_REDBALANCE = 4119;
  static const int MNOTE_OLYMPUS_TAG_BLUEBALANCE = 4120;
  static const int MNOTE_OLYMPUS_TAG_COLORMATRIXNUMBER = 4121;
  static const int MNOTE_OLYMPUS_TAG_SERIALNUMBER2 = 4122;
  static const int MNOTE_OLYMPUS_TAG_FLASHEXPOSURECOMP = 4131;
  static const int MNOTE_OLYMPUS_TAG_INTERNALFLASHTABLE = 4132;
  static const int MNOTE_OLYMPUS_TAG_EXTERNALFLASHGVALUE = 4133;
  static const int MNOTE_OLYMPUS_TAG_EXTERNALFLASHBOUNCE = 4134;
  static const int MNOTE_OLYMPUS_TAG_EXTERNALFLASHZOOM = 4135;
  static const int MNOTE_OLYMPUS_TAG_EXTERNALFLASHMODE = 4136;
  static const int MNOTE_OLYMPUS_TAG_CONTRAST = 4137;
  static const int MNOTE_OLYMPUS_TAG_SHARPNESSFACTOR = 4138;
  static const int MNOTE_OLYMPUS_TAG_COLORCONTROL = 4139;
  static const int MNOTE_OLYMPUS_TAG_IMAGEWIDTH = 4142;
  static const int MNOTE_OLYMPUS_TAG_IMAGEHEIGHT = 4143;
  static const int MNOTE_OLYMPUS_TAG_SCENEDETECT = 4144;
  static const int MNOTE_OLYMPUS_TAG_COMPRESSIONRATIO = 4148;
  static const int MNOTE_OLYMPUS_TAG_PREVIEWIMAGEVALID = 4149;
  static const int MNOTE_OLYMPUS_TAG_AFRESULT = 4152;
  static const int MNOTE_OLYMPUS_TAG_CCDSCANMODE = 4153;
  static const int MNOTE_OLYMPUS_TAG_NOISEREDUCTION = 4154;
  static const int MNOTE_OLYMPUS_TAG_INFINITYLENSSTEP = 4155;
  static const int MNOTE_OLYMPUS_TAG_NEARLENSSTEP = 4156;
  static const int MNOTE_OLYMPUS_TAG_LIGHTVALUECENTER = 4157;
  static const int MNOTE_OLYMPUS_TAG_LIGHTVALUEPERIPHERY = 4158;
  static const int MNOTE_EPSON_TAG_IMAGE_WIDTH = 523;
  static const int MNOTE_EPSON_TAG_IMAGE_HEIGHT = 524;
  static const int MNOTE_EPSON_TAG_SOFTWARE = 525;
  static const int MNOTE_SANYO_TAG_SEQUENTIALSHOT = 526;
  static const int MNOTE_SANYO_TAG_WIDERANGE = 527;
  static const int MNOTE_SANYO_TAG_COLORADJUSTMENTMODE = 528;
  static const int MNOTE_SANYO_TAG_FOCUSMODE = 530;
  static const int MNOTE_SANYO_TAG_QUICKSHOT = 531;
  static const int MNOTE_SANYO_TAG_SELFTIMER = 532;
  static const int MNOTE_SANYO_TAG_VOICEMEMO = 534;
  static const int MNOTE_SANYO_TAG_RECORDSHUTTERRELEASE = 535;
  static const int MNOTE_SANYO_TAG_FLICKERREDUCE = 536;
  static const int MNOTE_SANYO_TAG_OPTICALZOOM = 537;
  static const int MNOTE_SANYO_TAG_CCDSENSITIVITY = 538;
  static const int MNOTE_SANYO_TAG_DIGITALZOOM = 539;
  static const int MNOTE_SANYO_TAG_LIGHTSOURCESPECIAL = 541;
  static const int MNOTE_SANYO_TAG_RESAVED = 542;
  static const int MNOTE_SANYO_TAG_SCENESELECT = 543;
  static const int MNOTE_SANYO_TAG_MANUALFOCUSDISTANCE = 547;
  static const int MNOTE_SANYO_TAG_SEQUENCESHOTINTERVAL = 548;
}

final class _MnoteOlympusEntry extends ffi.Struct {
  @ffi.Int32()
  external int tag;

  @ffi.Int32()
  external int format;

  @ffi.UnsignedLong()
  external int components;

  external ffi.Pointer<ffi.UnsignedChar> data;

  @ffi.UnsignedInt()
  external int size;

  @ffi.Int32()
  external int order;
}

typedef MnoteOlympusEntry = _MnoteOlympusEntry;

abstract class OlympusVersion {
  static const int unrecognized = 0;
  static const int nikonV1 = 1;
  static const int nikonV2 = 2;
  static const int olympusV1 = 3;
  static const int olympusV2 = 4;
  static const int sanyoV1 = 5;
  static const int epsonV1 = 6;
  static const int nikonV0 = 7;
}

final class _ExifMnoteDataOlympus extends ffi.Struct {
  external ExifMnoteData parent;

  external ffi.Pointer<MnoteOlympusEntry> entries;

  @ffi.UnsignedInt()
  external int count;

  @ffi.Int32()
  external int order;

  @ffi.UnsignedInt()
  external int offset;

  @ffi.Int32()
  external int version;
}

abstract class _MnoteFujiTag {
  static const int MNOTE_FUJI_TAG_VERSION = 0;
  static const int MNOTE_FUJI_TAG_SERIAL_NUMBER = 16;
  static const int MNOTE_FUJI_TAG_QUALITY = 4096;
  static const int MNOTE_FUJI_TAG_SHARPNESS = 4097;
  static const int MNOTE_FUJI_TAG_WHITE_BALANCE = 4098;
  static const int MNOTE_FUJI_TAG_COLOR = 4099;
  static const int MNOTE_FUJI_TAG_TONE = 4100;
  static const int MNOTE_FUJI_TAG_UNKNOWN_1006 = 4102;
  static const int MNOTE_FUJI_TAG_UNKNOWN_1007 = 4103;
  static const int MNOTE_FUJI_TAG_UNKNOWN_1008 = 4104;
  static const int MNOTE_FUJI_TAG_UNKNOWN_1009 = 4105;
  static const int MNOTE_FUJI_TAG_UNKNOWN_100A = 4106;
  static const int MNOTE_FUJI_TAG_UNKNOWN_100B = 4107;
  static const int MNOTE_FUJI_TAG_FLASH_MODE = 4112;
  static const int MNOTE_FUJI_TAG_FLASH_STRENGTH = 4113;
  static const int MNOTE_FUJI_TAG_MACRO = 4128;
  static const int MNOTE_FUJI_TAG_FOCUS_MODE = 4129;
  static const int MNOTE_FUJI_TAG_UNKNOWN_1022 = 4130;
  static const int MNOTE_FUJI_TAG_FOCUS_POINT = 4131;
  static const int MNOTE_FUJI_TAG_UNKNOWN_1024 = 4132;
  static const int MNOTE_FUJI_TAG_UNKNOWN_1025 = 4133;
  static const int MNOTE_FUJI_TAG_SLOW_SYNC = 4144;
  static const int MNOTE_FUJI_TAG_PICTURE_MODE = 4145;
  static const int MNOTE_FUJI_TAG_UNKNOWN_1032 = 4146;
  static const int MNOTE_FUJI_TAG_CONT_TAKING = 4352;
  static const int MNOTE_FUJI_TAG_SEQUENCE_NUMBER = 4353;
  static const int MNOTE_FUJI_TAG_UNKNOWN_1200 = 4608;
  static const int MNOTE_FUJI_TAG_FINEPIX_COLOR = 4624;
  static const int MNOTE_FUJI_TAG_BLUR_CHECK = 4864;
  static const int MNOTE_FUJI_TAG_FOCUS_CHECK = 4865;
  static const int MNOTE_FUJI_TAG_AUTO_EXPOSURE_CHECK = 4866;
  static const int MNOTE_FUJI_TAG_UNKNOWN_1303 = 4867;
  static const int MNOTE_FUJI_TAG_DYNAMIC_RANGE = 5120;
  static const int MNOTE_FUJI_TAG_FILM_MODE = 5121;
  static const int MNOTE_FUJI_TAG_DYNAMIC_RANGE_SETTING = 5122;
  static const int MNOTE_FUJI_TAG_DEV_DYNAMIC_RANGE_SETTING = 5123;
  static const int MNOTE_FUJI_TAG_MIN_FOCAL_LENGTH = 5124;
  static const int MNOTE_FUJI_TAG_MAX_FOCAL_LENGTH = 5125;
  static const int MNOTE_FUJI_TAG_MAX_APERT_AT_MIN_FOC = 5126;
  static const int MNOTE_FUJI_TAG_MAX_APERT_AT_MAX_FOC = 5127;
  static const int MNOTE_FUJI_TAG_UNKNOWN_1408 = 5128;
  static const int MNOTE_FUJI_TAG_UNKNOWN_1409 = 5129;
  static const int MNOTE_FUJI_TAG_UNKNOWN_140A = 5130;
  static const int MNOTE_FUJI_TAG_UNKNOWN_1410 = 5136;
  static const int MNOTE_FUJI_TAG_UNKNOWN_1421 = 5153;
  static const int MNOTE_FUJI_TAG_UNKNOWN_4100 = 16640;
  static const int MNOTE_FUJI_TAG_UNKNOWN_4800 = 18432;
  static const int MNOTE_FUJI_TAG_FILE_SOURCE = 32768;
  static const int MNOTE_FUJI_TAG_ORDER_NUMBER = 32770;
  static const int MNOTE_FUJI_TAG_FRAME_NUMBER = 32771;
}

final class _MnoteFujiEntry extends ffi.Struct {
  @ffi.Int32()
  external int tag;

  @ffi.Int32()
  external int format;

  @ffi.UnsignedLong()
  external int components;

  external ffi.Pointer<ffi.UnsignedChar> data;

  @ffi.UnsignedInt()
  external int size;

  @ffi.Int32()
  external int order;
}

final class _MnoteFujiEntryPrivate extends ffi.Opaque {}

final class _ExifMnoteDataFuji extends ffi.Struct {
  external ExifMnoteData parent;

  external ffi.Pointer<MnoteFujiEntry> entries;

  @ffi.UnsignedInt()
  external int count;

  @ffi.Int32()
  external int order;

  @ffi.UnsignedInt()
  external int offset;
}

typedef MnoteFujiEntry = _MnoteFujiEntry;

final class ExifGPSIfdTagInfo extends ffi.Struct {
  @ffi.Uint16()
  external int tag;

  @ffi.Int32()
  external int format;

  @ffi.Uint16()
  external int components;

  @ffi.Uint16()
  external int default_size;

  external ffi.Pointer<ffi.Char> default_value;
}

final class _ExifLoader extends ffi.Opaque {}

/// ! Data used by the loader interface
typedef ExifLoader = _ExifLoader;

abstract class _MnoteCanonTag {
  static const int MNOTE_CANON_TAG_UNKNOWN_0 = 0;
  static const int MNOTE_CANON_TAG_SETTINGS_1 = 1;
  static const int MNOTE_CANON_TAG_FOCAL_LENGTH = 2;
  static const int MNOTE_CANON_TAG_UNKNOWN_3 = 3;
  static const int MNOTE_CANON_TAG_SETTINGS_2 = 4;
  static const int MNOTE_CANON_TAG_PANORAMA = 5;
  static const int MNOTE_CANON_TAG_IMAGE_TYPE = 6;
  static const int MNOTE_CANON_TAG_FIRMWARE = 7;
  static const int MNOTE_CANON_TAG_IMAGE_NUMBER = 8;
  static const int MNOTE_CANON_TAG_OWNER = 9;
  static const int MNOTE_CANON_TAG_UNKNOWN_10 = 10;
  static const int MNOTE_CANON_TAG_SERIAL_NUMBER = 12;
  static const int MNOTE_CANON_TAG_CAMERA_INFO = 13;
  static const int MNOTE_CANON_TAG_FILE_LENGTH = 14;
  static const int MNOTE_CANON_TAG_CUSTOM_FUNCS = 15;
  static const int MNOTE_CANON_TAG_MODEL_ID = 16;
  static const int MNOTE_CANON_TAG_MOVIE_INFO = 17;
  static const int MNOTE_CANON_TAG_AF_INFO = 18;
  static const int MNOTE_CANON_TAG_THUMBNAIL_VALID_AREA = 19;
  static const int MNOTE_CANON_TAG_SERIAL_NUMBER_FORMAT = 21;
  static const int MNOTE_CANON_TAG_SUPER_MACRO = 26;
  static const int MNOTE_CANON_TAG_DATE_STAMP_MODE = 28;
  static const int MNOTE_CANON_TAG_MY_COLORS = 29;
  static const int MNOTE_CANON_TAG_FIRMWARE_REVISION = 30;
  static const int MNOTE_CANON_TAG_CATEGORIES = 35;
  static const int MNOTE_CANON_TAG_FACEDETECT1 = 36;
  static const int MNOTE_CANON_TAG_FACEDETECT2 = 37;
  static const int MNOTE_CANON_TAG_AF_INFO2 = 38;
  static const int MNOTE_CANON_TAG_CONTRAST_INFO = 39;
  static const int MNOTE_CANON_TAG_IMAGE_UNIQUE_ID = 40;
  static const int MNOTE_CANON_TAG_WB_INFO = 41;
  static const int MNOTE_CANON_TAG_FACEDETECT3 = 47;
  static const int MNOTE_CANON_TAG_TIMEINFO = 53;
  static const int MNOTE_CANON_TAG_BATTERY_TYPE = 56;
  static const int MNOTE_CANON_TAG_AF_INFO3 = 60;
  static const int MNOTE_CANON_TAG_RAW_DATA_OFFSET = 129;
  static const int MNOTE_CANON_TAG_ORIGINAL_DECISION_DATA_OFFSET = 131;
  static const int MNOTE_CANON_TAG_PERSONAL_FUNCTIONS = 145;
  static const int MNOTE_CANON_TAG_PERSONAL_FUNCTIONS_VALUES = 146;
  static const int MNOTE_CANON_TAG_FILE_INFO = 147;
  static const int MNOTE_CANON_TAG_LENS_MODEL = 149;
  static const int MNOTE_CANON_TAG_CMOS_SERIAL = 150;
  static const int MNOTE_CANON_TAG_DUST_REMOVAL_DATA = 151;
  static const int MNOTE_CANON_TAG_CROP_INFO = 152;
  static const int MNOTE_CANON_TAG_CUSTOM_FUNCTIONS2 = 153;
  static const int MNOTE_CANON_TAG_ASPECT_INFO = 154;
  static const int MNOTE_CANON_TAG_COLOR_INFORMATION = 160;
  static const int MNOTE_CANON_TAG_TONE_CURVE_TABLE = 161;
  static const int MNOTE_CANON_TAG_SHARPNESS_TABLE = 162;
  static const int MNOTE_CANON_TAG_SHARPNESS_FREQ_TABLE = 163;
  static const int MNOTE_CANON_TAG_WHITEBALANCE_TABLE = 163;
  static const int MNOTE_CANON_TAG_COLOR_BALANCE = 169;
  static const int MNOTE_CANON_TAG_MEASURED_COLOR = 170;
  static const int MNOTE_CANON_TAG_COLOR_TEMPERATURE = 174;
  static const int MNOTE_CANON_TAG_CANON_FLAGS = 176;
  static const int MNOTE_CANON_TAG_MODIFIED_INFO = 177;
  static const int MNOTE_CANON_TAG_TONECURVE_MATCHING = 178;
  static const int MNOTE_CANON_TAG_WHITEBALANCE_MATCHING = 179;
  static const int MNOTE_CANON_TAG_COLOR_SPACE = 180;
  static const int MNOTE_CANON_TAG_PREVIEW_IMAGE_INFO = 182;
  static const int MNOTE_CANON_TAG_VRD_OFFSET = 208;
  static const int MNOTE_CANON_TAG_SENSOR_INFO = 224;
  static const int MNOTE_CANON_TAG_WB_PACKET = 16385;
  static const int MNOTE_CANON_TAG_COLOR_INFO = 16387;
  static const int MNOTE_CANON_TAG_FLAVOR = 16389;
  static const int MNOTE_CANON_TAG_PICTURESTYLE_USERDEF = 16392;
  static const int MNOTE_CANON_TAG_PICTURESTYLE_PC = 16393;
  static const int MNOTE_CANON_TAG_CUSTOMPICTURE_STYLE_FN = 16400;
  static const int MNOTE_CANON_TAG_AF_MICRO_ADJUST = 16403;
  static const int MNOTE_CANON_TAG_VIGNETTING_CORRECT = 16405;
  static const int MNOTE_CANON_TAG_VIGNETTING_CORRECT2 = 16406;
  static const int MNOTE_CANON_TAG_LIGHTINGOPT = 16408;
  static const int MNOTE_CANON_TAG_LENS_INFO = 16409;
  static const int MNOTE_CANON_TAG_AMBIENCE_INFO = 16416;
  static const int MNOTE_CANON_TAG_MULTI_EXPOSURE = 16417;
  static const int MNOTE_CANON_TAG_FILTER_INFO = 16420;
  static const int MNOTE_CANON_TAG_HDR_INFO = 16421;
  static const int MNOTE_CANON_TAG_AF_CONFIG = 16424;
  static const int MNOTE_CANON_TAG_RAW_BURST_INFO = 16447;
}

final class _MnoteCanonEntry extends ffi.Struct {
  @ffi.Int32()
  external int tag;

  @ffi.Int32()
  external int format;

  @ffi.UnsignedLong()
  external int components;

  external ffi.Pointer<ffi.UnsignedChar> data;

  @ffi.UnsignedInt()
  external int size;

  @ffi.Int32()
  external int order;
}

typedef MnoteCanonEntry = _MnoteCanonEntry;

final class _ExifMnoteDataCanon extends ffi.Struct {
  external ExifMnoteData parent;

  external ffi.Pointer<MnoteCanonEntry> entries;

  @ffi.UnsignedInt()
  external int count;

  @ffi.Int32()
  external int order;

  @ffi.UnsignedInt()
  external int offset;

  @ffi.Int32()
  external int options;
}

abstract class _MnotePentaxTag {
  static const int MNOTE_PENTAX_TAG_MODE = 1;
  static const int MNOTE_PENTAX_TAG_QUALITY = 2;
  static const int MNOTE_PENTAX_TAG_FOCUS = 3;
  static const int MNOTE_PENTAX_TAG_FLASH = 4;
  static const int MNOTE_PENTAX_TAG_UNKNOWN_05 = 5;
  static const int MNOTE_PENTAX_TAG_UNKNOWN_06 = 6;
  static const int MNOTE_PENTAX_TAG_WHITE_BALANCE = 7;
  static const int MNOTE_PENTAX_TAG_UNKNOWN_08 = 8;
  static const int MNOTE_PENTAX_TAG_UNKNOWN_09 = 9;
  static const int MNOTE_PENTAX_TAG_ZOOM = 10;
  static const int MNOTE_PENTAX_TAG_SHARPNESS = 11;
  static const int MNOTE_PENTAX_TAG_CONTRAST = 12;
  static const int MNOTE_PENTAX_TAG_SATURATION = 13;
  static const int MNOTE_PENTAX_TAG_UNKNOWN_14 = 14;
  static const int MNOTE_PENTAX_TAG_UNKNOWN_15 = 15;
  static const int MNOTE_PENTAX_TAG_UNKNOWN_16 = 16;
  static const int MNOTE_PENTAX_TAG_UNKNOWN_17 = 17;
  static const int MNOTE_PENTAX_TAG_UNKNOWN_18 = 18;
  static const int MNOTE_PENTAX_TAG_UNKNOWN_19 = 19;
  static const int MNOTE_PENTAX_TAG_ISO_SPEED = 20;
  static const int MNOTE_PENTAX_TAG_UNKNOWN_21 = 21;
  static const int MNOTE_PENTAX_TAG_COLOR = 23;
  static const int MNOTE_PENTAX_TAG_UNKNOWN_24 = 24;
  static const int MNOTE_PENTAX_TAG_UNKNOWN_25 = 25;
  static const int MNOTE_PENTAX_TAG_PRINTIM = 3584;
  static const int MNOTE_PENTAX_TAG_TZ_CITY = 4096;
  static const int MNOTE_PENTAX_TAG_TZ_DST = 4097;
  static const int MNOTE_PENTAX2_TAG_BASE = 16384;
  static const int MNOTE_PENTAX2_TAG_MODE = 16385;
  static const int MNOTE_PENTAX2_TAG_PREVIEW_SIZE = 16386;
  static const int MNOTE_PENTAX2_TAG_PREVIEW_LENGTH = 16387;
  static const int MNOTE_PENTAX2_TAG_PREVIEW_START = 16388;
  static const int MNOTE_PENTAX2_TAG_MODEL_ID = 16389;
  static const int MNOTE_PENTAX2_TAG_DATE = 16390;
  static const int MNOTE_PENTAX2_TAG_TIME = 16391;
  static const int MNOTE_PENTAX2_TAG_QUALITY = 16392;
  static const int MNOTE_PENTAX2_TAG_IMAGE_SIZE = 16393;
  static const int MNOTE_PENTAX2_TAG_PICTURE_MODE = 16395;
  static const int MNOTE_PENTAX2_TAG_FLASH_MODE = 16396;
  static const int MNOTE_PENTAX2_TAG_FOCUS_MODE = 16397;
  static const int MNOTE_PENTAX2_TAG_AFPOINT_SELECTED = 16398;
  static const int MNOTE_PENTAX2_TAG_AUTO_AFPOINT = 16399;
  static const int MNOTE_PENTAX2_TAG_FOCUS_POSITION = 16400;
  static const int MNOTE_PENTAX2_TAG_EXPOSURE_TIME = 16402;
  static const int MNOTE_PENTAX2_TAG_FNUMBER = 16403;
  static const int MNOTE_PENTAX2_TAG_ISO = 16404;
  static const int MNOTE_PENTAX2_TAG_EXPOSURE_COMPENSATION = 16406;
  static const int MNOTE_PENTAX2_TAG_METERING_MODE = 16407;
  static const int MNOTE_PENTAX2_TAG_AUTO_BRACKETING = 16408;
  static const int MNOTE_PENTAX2_TAG_WHITE_BALANCE = 16409;
  static const int MNOTE_PENTAX2_TAG_WHITE_BALANCE_MODE = 16410;
  static const int MNOTE_PENTAX2_TAG_BLUE_BALANCE = 16411;
  static const int MNOTE_PENTAX2_TAG_RED_BALANCE = 16412;
  static const int MNOTE_PENTAX2_TAG_FOCAL_LENGTH = 16413;
  static const int MNOTE_PENTAX2_TAG_DIGITAL_ZOOM = 16414;
  static const int MNOTE_PENTAX2_TAG_SATURATION = 16415;
  static const int MNOTE_PENTAX2_TAG_CONTRAST = 16416;
  static const int MNOTE_PENTAX2_TAG_SHARPNESS = 16417;
  static const int MNOTE_PENTAX2_TAG_WORLDTIME_LOCATION = 16418;
  static const int MNOTE_PENTAX2_TAG_HOMETOWN_CITY = 16419;
  static const int MNOTE_PENTAX2_TAG_DESTINATION_CITY = 16420;
  static const int MNOTE_PENTAX2_TAG_HOMETOWN_DST = 16421;
  static const int MNOTE_PENTAX2_TAG_DESTINATION_DST = 16422;
  static const int MNOTE_PENTAX2_TAG_FRAME_NUMBER = 16425;
  static const int MNOTE_PENTAX2_TAG_IMAGE_PROCESSING = 16434;
  static const int MNOTE_PENTAX2_TAG_PICTURE_MODE2 = 16435;
  static const int MNOTE_PENTAX2_TAG_DRIVE_MODE = 16436;
  static const int MNOTE_PENTAX2_TAG_COLOR_SPACE = 16439;
  static const int MNOTE_PENTAX2_TAG_IMAGE_AREA_OFFSET = 16440;
  static const int MNOTE_PENTAX2_TAG_RAW_IMAGE_SIZE = 16441;
  static const int MNOTE_PENTAX2_TAG_AFPOINTS_USED = 16444;
  static const int MNOTE_PENTAX2_TAG_LENS_TYPE = 16447;
  static const int MNOTE_PENTAX2_TAG_CAMERA_TEMPERATURE = 16455;
  static const int MNOTE_PENTAX2_TAG_NOISE_REDUCTION = 16457;
  static const int MNOTE_PENTAX2_TAG_FLASH_EXPOSURE_COMP = 16461;
  static const int MNOTE_PENTAX2_TAG_IMAGE_TONE = 16463;
  static const int MNOTE_PENTAX2_TAG_SHAKE_REDUCTION_INFO = 16476;
  static const int MNOTE_PENTAX2_TAG_BLACK_POINT = 16896;
  static const int MNOTE_PENTAX2_TAG_WHITE_POINT = 16897;
  static const int MNOTE_PENTAX2_TAG_AE_INFO = 16902;
  static const int MNOTE_PENTAX2_TAG_LENS_INFO = 16903;
  static const int MNOTE_PENTAX2_TAG_FLASH_INFO = 16904;
  static const int MNOTE_PENTAX2_TAG_CAMERA_INFO = 16917;
  static const int MNOTE_PENTAX2_TAG_BATTERY_INFO = 16918;
  static const int MNOTE_PENTAX2_TAG_HOMETOWN_CITY_CODE = 20480;
  static const int MNOTE_PENTAX2_TAG_DESTINATION_CITY_CODE = 20481;
  static const int MNOTE_CASIO2_TAG_BASE = 16384;
  static const int MNOTE_CASIO2_TAG_PREVIEW_START = 24576;
  static const int MNOTE_CASIO2_TAG_WHITE_BALANCE_BIAS = 24593;
  static const int MNOTE_CASIO2_TAG_WHITE_BALANCE = 24594;
  static const int MNOTE_CASIO2_TAG_OBJECT_DISTANCE = 24610;
  static const int MNOTE_CASIO2_TAG_FLASH_DISTANCE = 24628;
  static const int MNOTE_CASIO2_TAG_RECORD_MODE = 28672;
  static const int MNOTE_CASIO2_TAG_SELF_TIMER = 28673;
  static const int MNOTE_CASIO2_TAG_QUALITY = 28674;
  static const int MNOTE_CASIO2_TAG_FOCUS_MODE = 28675;
  static const int MNOTE_CASIO2_TAG_TIME_ZONE = 28678;
  static const int MNOTE_CASIO2_TAG_BESTSHOT_MODE = 28679;
  static const int MNOTE_CASIO2_TAG_CCS_ISO_SENSITIVITY = 28692;
  static const int MNOTE_CASIO2_TAG_COLOR_MODE = 28693;
  static const int MNOTE_CASIO2_TAG_ENHANCEMENT = 28694;
  static const int MNOTE_CASIO2_TAG_FINER = 28695;
}

final class _MnotePentaxEntry extends ffi.Struct {
  @ffi.Int32()
  external int tag;

  @ffi.Int32()
  external int format;

  @ffi.UnsignedLong()
  external int components;

  external ffi.Pointer<ffi.UnsignedChar> data;

  @ffi.UnsignedInt()
  external int size;

  @ffi.Int32()
  external int order;
}

typedef MnotePentaxEntry = _MnotePentaxEntry;

abstract class PentaxVersion {
  static const int pentaxV1 = 1;
  static const int pentaxV2 = 2;
  static const int pentaxV3 = 3;
  static const int casioV2 = 4;
}

final class _ExifMnoteDataPentax extends ffi.Struct {
  external ExifMnoteData parent;

  external ffi.Pointer<MnotePentaxEntry> entries;

  @ffi.UnsignedInt()
  external int count;

  @ffi.Int32()
  external int order;

  @ffi.UnsignedInt()
  external int offset;

  @ffi.Int32()
  external int version;
}
